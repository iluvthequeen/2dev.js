/*
 *
 * 2dev.js Version 2
 * https://github.com/masgalascharles/2dev.js
 *
 */

const K_BACKSPACE="Backspace",K_TAB="Tab",K_ENTER="Enter",K_SHIFTLEFT="ShiftLeft",K_SHIFTRIGHT="ShiftRight",K_CONTROLLEFT="ControlLeft",K_CONTROLRIGHT="ControlRight",K_ALTLEFT="AltLeft",K_ALTRIGHT="AltRight",K_PAUSE="Pause",K_CAPSLOCK="CapsLock",K_ESCAPE="Escape",K_SPACE="Space",K_PAGEUP="PageUp",K_PAGEDOWN="PageDown",K_END="End",K_HOME="Home",K_ARROWUP="ArrowUp",K_ARROWDOWN="ArrowDown",K_ARROWLEFT="ArrowLeft",K_ARROWRIGHT="ArrowRight",K_PRINTSCREEN="PrintScreen",K_INSERT="Insert",K_DELETE="Delete",K_0="Digit0",K_1="Digit1",K_2="Digit2",K_3="Digit3",K_4="Digit4",K_5="Digit5",K_6="Digit6",K_7="Digit7",K_8="Digit8",K_9="Digit9",K_A="KeyA",K_B="KeyB",K_C="KeyC",K_D="KeyD",K_E="KeyE",K_F="KeyF",K_G="KeyG",K_H="KeyH",K_I="KeyI",K_J="KeyJ",K_K="KeyK",K_L="KeyL",K_M="KeyM",K_N="KeyN",K_O="KeyO",K_P="KeyP",K_Q="KeyQ",K_R="KeyR",K_S="KeyS",K_T="KeyT",K_U="KeyU",K_V="KeyV",K_W="KeyW",K_X="KeyX",K_Y="KeyY",K_Z="KeyZ",K_LEFTWINDOW="MetaLeft",K_RIGHTWINDOW="MetaRight",K_CONTEXTMENU="ContextMenu",K_NUM0="Numpad0",K_NUM1="Numpad1",K_NUM2="Numpad2",K_NUM3="Numpad3",K_NUM4="Numpad4",K_NUM5="Numpad5",K_NUM6="Numpad6",K_NUM7="Numpad7",K_NUM8="Numpad8",K_NUM9="Numpad9",K_MULTIPLY="NumpadMultiply",K_ADD="NumpadAdd",K_SUBTRACT="NumpadSubtract",K_DECIMAL="NumpadDecimal",K_DIVIDE="NumpadDivide",K_F1="F1",K_F2="F2",K_F3="F3",K_F4="F4",K_F5="F5",K_F6="F6",K_F7="F7",K_F8="F8",K_F9="F9",K_F10="F10",K_F11="F11",K_F12="F12",K_NUMLOCK="NumLock",K_SCROLLLOCK="ScrollLock",K_SEMICOLON="Semicolon",K_EQUAL="Equal",K_COMMA="Comma",K_MINUS="Minus",K_PERIOD="Period",K_SLASH="Slash",K_BACKQUOTE="Backquote",K_BRACKETLEFT="BracketLeft",K_BACKSLASH="Backslash",K_BRACKETRIGHT="BracketRight",K_QUOTE="Quote",C_BLACK="#000000",C_WHITE="#ffffff",C_SILVER="#c0c0c0",C_GRAY="#808080",C_MAROON="#800000",C_RED="#ff0000",C_PURPLE="#800080",C_FUCHSIA="#ff00ff",C_GREEN="#008000",C_LIME="#00ff00",C_OLIVE="#808000",C_YELLOW="#ffff00",C_NAVY="#000080",C_BLUE="#0000ff",C_TEAL="#008080",C_AQUA="#00ffff",LoadedImgs=[],LoadedSounds=[],Data={Save:function(name="",value=""){return localStorage.setItem(name,value),{name:name,value:value}},Get:function(name=""){return localStorage.getItem(name)},Delete:function(name=""){return localStorage.removeItem(name),name},Clear:function(){return localStorage.clear()}},On={KeyDown:function(key="",func=new Function,shouldPreventDefault=!1){let canExe=!0;return document.body.addEventListener("keydown",(function(event){event.code==key&&canExe&&(shouldPreventDefault&&event.preventDefault(),func(),canExe=!1)}),!1),document.body.addEventListener("keyup",(function(event){event.code==key&&(canExe=!0)}),!1),key},KeyUp:function(key="",func=new Function,shouldPreventDefault=!1){let canExe=!0;return document.body.addEventListener("keydown",(function(event){event.code==key&&(canExe=!0)}),!1),document.body.addEventListener("keyup",(function(event){event.code==key&&canExe&&(shouldPreventDefault&&event.preventDefault(),func(),canExe=!1)}),!1),key},LeftMouseDown:void 0,LeftMouseUp:void 0,MouseWheelDown:void 0,MouseWheelUp:void 0,RightMouseDown:void 0,RightMouseUp:void 0},Mouse={x:0,y:0,Show:function(){document.querySelector("*").style.cursor="default"},Hide:function(){document.querySelector("*").style.cursor="none"}},KeysPressed={};let FPS=0,ExactFPS=0,LeftMouseDown=!1,MouseWheelDown=!1,RightMouseDown=!1,ShowContextMenu=!0;const Canvas=class{constructor(parentElement=document.body,width=100,height=100){const thisCanvas=document.createElement("canvas");thisCanvas.setAttribute("width",width+"px"),thisCanvas.setAttribute("height",height+"px"),parentElement.appendChild(thisCanvas);const thisClass=this,ctx=thisCanvas.getContext("2d");let background,objects=[];this.HTML=thisCanvas,this.ctx=ctx,this.style=thisCanvas.style,this.width=width,this.height=height,this.centerX=width/2,this.centerY=height/2,this.objects=objects,this.ShowContextMenu=!0,this.Mouse={x:0,y:0,Show:function(){thisCanvas.style.cursor="default"},Hide:function(){thisCanvas.style.cursor="none"}},this.On={KeyDown:function(key="",func=new Function,shouldPreventDefault=!1){let canExe=!0;return thisCanvas.addEventListener("keydown",(function(event){event.code==key&&canExe&&(shouldPreventDefault&&event.preventDefault(),func(),canExe=!1)}),!1),document.body.addEventListener("keyup",(function(event){event.code==key&&(canExe=!0)}),!1),key},KeyUp:function(key="",func=new Function,shouldPreventDefault=!1){let canExe=!0;return document.body.addEventListener("keydown",(function(event){event.code==key&&(canExe=!0)}),!1),thisCanvas.addEventListener("keyup",(function(event){event.code==key&&canExe&&(shouldPreventDefault&&event.preventDefault(),func(),canExe=!1)}),!1),key},LeftMouseDown:void 0,LeftMouseUp:void 0,MouseWheelDown:void 0,MouseWheelUp:void 0,RightMouseDown:void 0,RightMouseUp:void 0,MouseOver:function(func=new Function){thisCanvas.addEventListener("mouseover",(function(){func()}))},MouseLeave:function(func=new Function){thisCanvas.addEventListener("mouseleave",(function(){func()}))}},this.BackgroundColor=function(color="#000000"){return background={type:"color",color:color},color},this.BackgroundImg=function(src=""){return background={type:"image",img:new Image},background.img.src=src,src},this.Fill=function(color="#000000"){return objects.push({type:"fill",color:color}),color},this.Draw=function(){for(let i=0;i<arguments.length;i++)objects.push(arguments[i])},this.Erase=function(){for(let i=0;i<arguments.length;i++)objects.splice(objects.indexOf(arguments[i]),1)},this.Clear=function(){ctx.clearRect(0,0,thisCanvas.width,thisCanvas.height),background=void 0,objects=[]},this.SetClass=function(newClass=""){return thisCanvas.setAttribute("class",newClass),newClass},this.SetId=function(newId=""){return thisCanvas.setAttribute("id",newId),newId},this.SetBorder=function(width=1,color="#000000"){return thisCanvas.style.border=width+"px solid"+color,{width:width,color:color}},this.RemoveBorder=function(){thisCanvas.style.border=""},this.Style=function(property="",value=""){return thisCanvas.style[property]=value,{property:property,value:value}},this.Center=function(){thisCanvas.style.top=thisCanvas.style.left="50%",thisCanvas.style.position="absolute",thisCanvas.style.transform="translate(-50%, -50%)"},function update(){!function draw(){ctx.clearRect(0,0,thisCanvas.width,thisCanvas.height),null!=background&&("color"==background.type?(ctx.fillStyle=background.color,ctx.fillRect(0,0,thisCanvas.width,thisCanvas.height)):"image"==background.type&&ctx.drawImage(background.img,0,0,thisCanvas.width,thisCanvas.height));for(let i=0;i<objects.length;i++)if("fill"==objects[i].type)ctx.shadowOffsetX=0,ctx.shadowOffsetY=0,ctx.shadowBlur=0,ctx.shadowColor=void 0,ctx.globalAlpha=objects[i].opacity/100,ctx.fillStyle=objects[i].color,ctx.fillRect(0,0,thisCanvas.width,thisCanvas.height);else if(objects[i].visible){if("img"==objects[i].type){const radians=objects[i].rotation*Math.PI/180;ctx.globalAlpha=objects[i].opacity/100,objects[i].showShadow?(ctx.shadowOffsetX=objects[i].shadowOffsetX,ctx.shadowOffsetY=objects[i].shadowOffsetY,ctx.shadowBlur=objects[i].shadowBlur,ctx.shadowColor=objects[i].shadowColor):(ctx.shadowOffsetX=0,ctx.shadowOffsetY=0,ctx.shadowBlur=0,ctx.shadowColor=void 0),ctx.save(),ctx.translate(objects[i].x,objects[i].y),ctx.rotate(radians),ctx.drawImage(objects[i].img,-objects[i].width/2,-objects[i].height/2,objects[i].width,objects[i].height),ctx.shadowOffsetX=0,ctx.shadowOffsetY=0,ctx.shadowBlur=0,ctx.shadowColor=void 0,objects[i].showBorder&&(ctx.lineWidth=objects[i].borderWidth,ctx.strokeStyle=objects[i].borderColor,ctx.strokeRect(-objects[i].width/2+objects[i].borderWidth/2,-objects[i].height/2+objects[i].borderWidth/2,objects[i].width-objects[i].borderWidth,objects[i].height-objects[i].borderWidth)),objects[i].showTopBorder&&(ctx.fillStyle=objects[i].topBorderColor,ctx.fillRect(-objects[i].width/2,-objects[i].height/2,objects[i].width,objects[i].topBorderWidth)),objects[i].showBottomBorder&&(ctx.fillStyle=objects[i].bottomBorderColor,ctx.fillRect(-objects[i].width/2,objects[i].height/2-objects[i].bottomBorderWidth,objects[i].width,objects[i].bottomBorderWidth)),objects[i].showLeftBorder&&(ctx.fillStyle=objects[i].leftBorderColor,ctx.fillRect(-objects[i].width/2,-objects[i].height/2,objects[i].leftBorderWidth,objects[i].height)),objects[i].showRightBorder&&(ctx.fillStyle=objects[i].rightBorderColor,ctx.fillRect(objects[i].width/2-objects[i].rightBorderWidth,-objects[i].height/2,objects[i].rightBorderWidth,objects[i].height)),ctx.restore()}else if("line"==objects[i].type)ctx.lineWidth=objects[i].lineWidth,ctx.strokeStyle=objects[i].color,ctx.globalAlpha=objects[i].opacity/100,objects[i].showShadow?(ctx.shadowOffsetX=objects[i].shadowOffsetX,ctx.shadowOffsetY=objects[i].shadowOffsetY,ctx.shadowBlur=objects[i].shadowBlur,ctx.shadowColor=objects[i].shadowColor):(ctx.shadowOffsetX=0,ctx.shadowOffsetY=0,ctx.shadowBlur=0,ctx.shadowColor=void 0),ctx.beginPath(),ctx.moveTo(objects[i].point1.x,objects[i].point1.y),ctx.lineTo(objects[i].point2.x,objects[i].point2.y),ctx.stroke();else if("polygon"==objects[i].type){const points=objects[i].points,radians=objects[i].rotation*Math.PI/180;if(ctx.save(),ctx.translate(objects[i].x,objects[i].y),ctx.rotate(radians),ctx.beginPath(),objects[i].showShadow?(ctx.shadowOffsetX=objects[i].shadowOffsetX,ctx.shadowOffsetY=objects[i].shadowOffsetY,ctx.shadowBlur=objects[i].shadowBlur,ctx.shadowColor=objects[i].shadowColor):(ctx.shadowOffsetX=0,ctx.shadowOffsetY=0,ctx.shadowBlur=0,ctx.shadowColor=void 0),objects[i].stroke){const lineWidth=objects[i].lineWidth;let j=points.length-1,fixedX=1-Math.abs(lineWidth/points[j].offsetX)/2,fixedY=1-Math.abs(lineWidth/points[j].offsetY)/2;for(ctx.moveTo(points[j].offsetX*fixedX,points[j].offsetY*fixedY),j=0;j<points.length;j++)fixedX=1-Math.abs(lineWidth/points[j].offsetX)/2,fixedY=1-Math.abs(lineWidth/points[j].offsetY)/2,ctx.lineTo(points[j].offsetX*fixedX,points[j].offsetY*fixedY);ctx.globalAlpha=objects[i].opacity/100,ctx.lineWidth=lineWidth,ctx.strokeStyle=objects[i].color,ctx.stroke()}else{ctx.moveTo(points[points.length-1].offsetX,points[points.length-1].offsetY);for(let i=0;i<points.length;i++)ctx.lineTo(points[i].offsetX,points[i].offsetY);ctx.globalAlpha=objects[i].opacity/100,ctx.fillStyle=objects[i].color,ctx.fill()}if(objects[i].showBorder){ctx.shadowOffsetX=0,ctx.shadowOffsetY=0,ctx.shadowBlur=0,ctx.shadowColor=void 0;const borderWidth=objects[i].borderWidth;let j=points.length-1,fixedX=1-Math.abs(borderWidth/points[j].offsetX)/2,fixedY=1-Math.abs(borderWidth/points[j].offsetY)/2;for(ctx.moveTo(points[j].offsetX*fixedX,points[j].offsetY*fixedY),j=0;j<points.length;j++)fixedX=1-Math.abs(borderWidth/points[j].offsetX)/2,fixedY=1-Math.abs(borderWidth/points[j].offsetY)/2,ctx.lineTo(points[j].offsetX*fixedX,points[j].offsetY*fixedY);ctx.globalAlpha=objects[i].opacity/100,ctx.lineWidth=borderWidth,ctx.strokeStyle=objects[i].borderColor,ctx.stroke()}ctx.restore()}else if("rect"==objects[i].type){const radians=objects[i].rotation*Math.PI/180;ctx.globalAlpha=objects[i].opacity/100,ctx.save(),ctx.translate(objects[i].x,objects[i].y),ctx.rotate(radians),objects[i].showShadow?(ctx.shadowOffsetX=objects[i].shadowOffsetX,ctx.shadowOffsetY=objects[i].shadowOffsetY,ctx.shadowBlur=objects[i].shadowBlur,ctx.shadowColor=objects[i].shadowColor):(ctx.shadowOffsetX=0,ctx.shadowOffsetY=0,ctx.shadowBlur=0,ctx.shadowColor=void 0),objects[i].stroke?(ctx.lineWidth=objects[i].lineWidth,ctx.strokeStyle=objects[i].color,ctx.strokeRect(-objects[i].width/2+objects[i].lineWidth/2,-objects[i].height/2+objects[i].lineWidth/2,objects[i].width-objects[i].lineWidth,objects[i].height-objects[i].lineWidth)):(ctx.fillStyle=objects[i].color,ctx.fillRect(-objects[i].width/2,-objects[i].height/2,objects[i].width,objects[i].height)),ctx.shadowOffsetX=0,ctx.shadowOffsetY=0,ctx.shadowBlur=0,ctx.shadowColor=void 0,objects[i].showBorder&&(ctx.lineWidth=objects[i].borderWidth,ctx.strokeStyle=objects[i].borderColor,ctx.strokeRect(-objects[i].width/2+objects[i].borderWidth/2,-objects[i].height/2+objects[i].borderWidth/2,objects[i].width-objects[i].borderWidth,objects[i].height-objects[i].borderWidth)),objects[i].showTopBorder&&(ctx.fillStyle=objects[i].topBorderColor,ctx.fillRect(-objects[i].width/2,-objects[i].height/2,objects[i].width,objects[i].topBorderWidth)),objects[i].showBottomBorder&&(ctx.fillStyle=objects[i].bottomBorderColor,ctx.fillRect(-objects[i].width/2,objects[i].height/2-objects[i].bottomBorderWidth,objects[i].width,objects[i].bottomBorderWidth)),objects[i].showLeftBorder&&(ctx.fillStyle=objects[i].leftBorderColor,ctx.fillRect(-objects[i].width/2,-objects[i].height/2,objects[i].leftBorderWidth,objects[i].height)),objects[i].showRightBorder&&(ctx.fillStyle=objects[i].rightBorderColor,ctx.fillRect(objects[i].width/2-objects[i].rightBorderWidth,-objects[i].height/2,objects[i].rightBorderWidth,objects[i].height)),ctx.restore()}else if("circle"==objects[i].type)ctx.globalAlpha=objects[i].opacity/100,ctx.beginPath(),objects[i].showShadow?(ctx.shadowOffsetX=objects[i].shadowOffsetX,ctx.shadowOffsetY=objects[i].shadowOffsetY,ctx.shadowBlur=objects[i].shadowBlur,ctx.shadowColor=objects[i].shadowColor):(ctx.shadowOffsetX=0,ctx.shadowOffsetY=0,ctx.shadowBlur=0,ctx.shadowColor=void 0),objects[i].stroke?(ctx.lineWidth=objects[i].lineWidth,ctx.strokeStyle=objects[i].color,ctx.arc(objects[i].x,objects[i].y,objects[i].radius-objects[i].lineWidth/2,0,2*Math.PI),ctx.stroke()):(ctx.fillStyle=objects[i].color,ctx.arc(objects[i].x,objects[i].y,objects[i].radius,0,2*Math.PI),ctx.fill()),objects[i].showBorder&&(ctx.lineWidth=objects[i].borderWidth,ctx.strokeStyle=objects[i].borderColor,ctx.shadowOffsetX=0,ctx.shadowOffsetY=0,ctx.shadowBlur=0,ctx.shadowColor=void 0,ctx.beginPath(),ctx.arc(objects[i].x,objects[i].y,objects[i].radius-objects[i].borderWidth/2+.5,0,2*Math.PI),ctx.stroke());else if("text"==objects[i].type){const radians=objects[i].rotation*Math.PI/180;ctx.globalAlpha=objects[i].opacity/100,ctx.save(),ctx.translate(objects[i].x,objects[i].y),ctx.rotate(radians),objects[i].showShadow?(ctx.shadowOffsetX=objects[i].shadowOffsetX,ctx.shadowOffsetY=objects[i].shadowOffsetY,ctx.shadowBlur=objects[i].shadowBlur,ctx.shadowColor=objects[i].shadowColor):(ctx.shadowOffsetX=0,ctx.shadowOffsetY=0,ctx.shadowBlur=0,ctx.shadowColor=void 0),ctx.textAlign="center",ctx.textBaseline="middle",ctx.font=objects[i].fontSize+"px "+objects[i].font,ctx.fillStyle=objects[i].color,ctx.fillText(objects[i].text,0,0),ctx.restore()}}else"custom"==objects[i].type&&"function"==typeof objects[i].Draw&&objects[i].Draw()}(),thisCanvas.width!=thisClass.width&&thisCanvas.setAttribute("width",thisClass.width+"px"),thisCanvas.height!=thisClass.height&&thisCanvas.setAttribute("height",thisClass.height+"px"),thisClass.centerX!=thisCanvas.width/2&&(thisClass.centerX=thisCanvas.width/2),thisClass.centerY!=thisCanvas.height/2&&(thisClass.centerY=thisCanvas.height/2),JSON.stringify(thisClass.objects)!=JSON.stringify(objects)&&(thisClass.objects=objects),requestAnimationFrame(update)}(),thisCanvas.addEventListener("mousedown",(function(event){let browser,leftMouse=1,mouseWheel=2,rightMouse=3;if("which"in event)browser="which";else{if(!("button"in event))return void console.error("'event.which' and 'event.button' are unsupported in this browser.");browser="button",leftMouse--,mouseWheel--,rightMouse--}event[browser]==leftMouse?(LeftMouseDown=!0,"function"==typeof thisClass.On.LeftMouseDown&&thisClass.On.LeftMouseDown()):event[browser]==mouseWheel?(MouseWheelDown=!0,"function"==typeof thisClass.On.MouseWheelDown&&(event.preventDefault(),thisClass.On.MouseWheelDown())):event[browser]==rightMouse&&(RightMouseDown=!0,"function"==typeof thisClass.On.RightMouseDown&&thisClass.On.RightMouseDown());const mouseX=thisClass.Mouse.x,mouseY=thisClass.Mouse.y;function getRotatedPos(origin,point,angle){return{x:Math.cos(angle)*(point.x-origin.x)+Math.sin(angle)*(point.y-origin.y)+origin.x,y:Math.cos(angle)*(point.y-origin.y)-Math.sin(angle)*(point.x-origin.x)+origin.y}}for(let i=0;i<objects.length;i++)if("text"!=objects[i].type&&"custom"!=objects[i].type&&"object"==typeof objects[i].On&&(null!=objects[i].On.LeftMouseDown||null!=objects[i].On.RightMouseDown))if("rect"==objects[i].type||"img"==objects[i].type){const radians=objects[i].rotation*Math.PI/180,rectX=objects[i].x-objects[i].width/2,rectY=objects[i].y-objects[i].height/2,newPoint=getRotatedPos(objects[i],{x:mouseX,y:mouseY},radians);newPoint.x>rectX&&newPoint.x<rectX+objects[i].width&&newPoint.y>rectY&&newPoint.y<rectY+objects[i].height&&(event[browser]==leftMouse&&"function"==typeof objects[i].On.LeftMouseDown?objects[i].On.LeftMouseDown():event[browser]==mouseWheel&&"function"==typeof objects[i].On.MouseWheelDown?(event.preventDefault(),objects[i].On.MouseWheelDown()):event[browser]==rightMouse&&"function"==typeof objects[i].On.RightMouseDown&&objects[i].On.RightMouseDown())}else if("polygon"==objects[i].type){const points=objects[i].points,radians=objects[i].rotation*Math.PI/180,mouse=getRotatedPos(objects[i],{x:mouseX,y:mouseY},radians);let collision=!1,next=0;for(let current=0;current<points.length;current++){next=current+1,next==points.length&&(next=0);const currentPoint=points[current],nextPoint=points[next];(currentPoint.y>=mouse.y&&nextPoint.y<mouse.y||currentPoint.y<mouse.y&&nextPoint.y>=mouse.y)&&mouse.x<(nextPoint.x-currentPoint.x)*(mouse.y-currentPoint.y)/(nextPoint.y-currentPoint.y)+currentPoint.x&&(collision=!collision)}collision&&(event[browser]==leftMouse&&"function"==typeof objects[i].On.LeftMouseDown?objects[i].On.LeftMouseDown():event[browser]==mouseWheel&&"function"==typeof objects[i].On.MouseWheelDown?(event.preventDefault(),objects[i].On.MouseWheelDown()):event[browser]==rightMouse&&"function"==typeof objects[i].On.RightMouseDown&&objects[i].On.RightMouseDown())}else if("circle"==objects[i].type){const distX=Math.abs(mouseX-objects[i].x),distY=Math.abs(mouseY-objects[i].y);Math.sqrt(distX**2+distY**2)<objects[i].radius&&(event[browser]==leftMouse&&"function"==typeof objects[i].On.LeftMouseDown?objects[i].On.LeftMouseDown():event[browser]==mouseWheel&&"function"==typeof objects[i].On.MouseWheelDown?(event.preventDefault(),objects[i].On.MouseWheelDown()):event[browser]==rightMouse&&"function"==typeof objects[i].On.RightMouseDown&&objects[i].On.RightMouseDown())}else if("line"==objects[i].type){function getAngle(centerX,centerY,endX,endY){const distX=endX-centerX,distY=endY-centerY;return Math.atan2(distY,distX)}let point1=objects[i].point1,point2=objects[i].point2;const midX=(point1.x+point2.x)/2,midY=(point1.y+point2.y)/2,radians=getAngle(midX,midY,point2.x,point2.y),lineWidth=objects[i].lineWidth,mouse=getRotatedPos({x:midX,y:midY},{x:mouseX,y:mouseY},radians);point1=getRotatedPos({x:midX,y:midY},point1,radians),point2=getRotatedPos({x:midX,y:midY},point2,radians);const rect={x:point1.x,y:point1.y-lineWidth/2,width:Math.abs(point1.x-point2.x),height:lineWidth};mouse.x>rect.x&&mouse.x<rect.x+rect.width&&mouse.y>rect.y&&mouse.y<rect.y+rect.height&&(event[browser]==leftMouse&&"function"==typeof objects[i].On.LeftMouseDown?objects[i].On.LeftMouseDown():event[browser]==mouseWheel&&"function"==typeof objects[i].On.MouseWheelDown?(event.preventDefault(),objects[i].On.MouseWheelDown()):event[browser]==rightMouse&&"function"==typeof objects[i].On.RightMouseDown&&objects[i].On.RightMouseDown())}}),!1),thisCanvas.addEventListener("mouseup",(function(event){let browser,leftMouse=1,mouseWheel=2,rightMouse=3;if("which"in event)browser="which";else{if(!("button"in event))return void console.error("'event.which' and 'event.button' are unsupported in this browser.");browser="button",leftMouse--,mouseWheel--,rightMouse--}event[browser]==leftMouse?(LeftMouseDown=!1,"function"==typeof thisClass.On.LeftMouseUp&&thisClass.On.LeftMouseUp()):event[browser]==mouseWheel?(MouseWheelDown=!1,"function"==typeof thisClass.On.MouseWheelUp&&(event.preventDefault(),thisClass.On.MouseWheelUp())):event[browser]==rightMouse&&(RightMouseDown=!1,"function"==typeof thisClass.On.RightMouseUp&&thisClass.On.RightMouseUp());const mouseX=thisClass.Mouse.x,mouseY=thisClass.Mouse.y;function getRotatedPos(origin,point,angle){return{x:Math.cos(angle)*(point.x-origin.x)+Math.sin(angle)*(point.y-origin.y)+origin.x,y:Math.cos(angle)*(point.y-origin.y)-Math.sin(angle)*(point.x-origin.x)+origin.y}}for(let i=0;i<objects.length;i++)if("text"!=objects[i].type&&"custom"!=objects[i].type&&"object"==typeof objects[i].On&&(null!=objects[i].On.LeftMouseUp||null!=objects[i].On.RightMouseUp))if("rect"==objects[i].type||"img"==objects[i].type){const radians=objects[i].rotation*Math.PI/180,rectX=objects[i].x-objects[i].width/2,rectY=objects[i].y-objects[i].height/2,newPoint=getRotatedPos(objects[i],{x:mouseX,y:mouseY},radians);newPoint.x>rectX&&newPoint.x<rectX+objects[i].width&&newPoint.y>rectY&&newPoint.y<rectY+objects[i].height&&(event[browser]==leftMouse&&"function"==typeof objects[i].On.LeftMouseUp?objects[i].On.LeftMouseUp():event[browser]==mouseWheel&&"function"==typeof objects[i].On.MouseWheelUp?(event.preventDefault(),objects[i].On.MouseWheelUp()):event[browser]==rightMouse&&"function"==typeof objects[i].On.RightMouseUp&&objects[i].On.RightMouseUp())}else if("polygon"==objects[i].type){const points=objects[i].points,radians=objects[i].rotation*Math.PI/180,mouse=getRotatedPos(objects[i],{x:mouseX,y:mouseY},radians);let collision=!1,next=0;for(let current=0;current<points.length;current++){next=current+1,next==points.length&&(next=0);const currentPoint=points[current],nextPoint=points[next];(currentPoint.y>=mouse.y&&nextPoint.y<mouse.y||currentPoint.y<mouse.y&&nextPoint.y>=mouse.y)&&mouse.x<(nextPoint.x-currentPoint.x)*(mouse.y-currentPoint.y)/(nextPoint.y-currentPoint.y)+currentPoint.x&&(collision=!collision)}collision&&(event[browser]==leftMouse&&"function"==typeof objects[i].On.LeftMouseUp?objects[i].On.LeftMouseUp():event[browser]==mouseWheel&&"function"==typeof objects[i].On.MouseWheelUp?(event.preventDefault(),objects[i].On.MouseWheelUp()):event[browser]==rightMouse&&"function"==typeof objects[i].On.RightMouseUp&&objects[i].On.RightMouseUp())}else if("circle"==objects[i].type){const distX=Math.abs(mouseX-objects[i].x),distY=Math.abs(mouseY-objects[i].y);Math.sqrt(distX**2+distY**2)<objects[i].radius&&(event[browser]==leftMouse&&"function"==typeof objects[i].On.LeftMouseUp?objects[i].On.LeftMouseUp():event[browser]==mouseWheel&&"function"==typeof objects[i].On.MouseWheelUp?(event.preventDefault(),objects[i].On.MouseWheelUp()):event[browser]==rightMouse&&"function"==typeof objects[i].On.RightMouseUp&&objects[i].On.RightMouseUp())}else if("line"==objects[i].type){function getAngle(centerX,centerY,endX,endY){const distX=endX-centerX,distY=endY-centerY;return Math.atan2(distY,distX)}let point1=objects[i].point1,point2=objects[i].point2;const midX=(point1.x+point2.x)/2,midY=(point1.y+point2.y)/2,radians=getAngle(midX,midY,point2.x,point2.y),lineWidth=objects[i].lineWidth,mouse=getRotatedPos({x:midX,y:midY},{x:mouseX,y:mouseY},radians);point1=getRotatedPos({x:midX,y:midY},point1,radians),point2=getRotatedPos({x:midX,y:midY},point2,radians);const rect={x:point1.x,y:point1.y-lineWidth/2,width:Math.abs(point1.x-point2.x),height:lineWidth};mouse.x>rect.x&&mouse.x<rect.x+rect.width&&mouse.y>rect.y&&mouse.y<rect.y+rect.height&&(event[browser]==leftMouse&&"function"==typeof objects[i].On.LeftMouseUp?objects[i].On.LeftMouseUp():event[browser]==mouseWheel&&"function"==typeof objects[i].On.MouseWheelUp?(event.preventDefault(),objects[i].On.MouseWheelUp()):event[browser]==rightMouse&&"function"==typeof objects[i].On.RightMouseUp&&objects[i].On.RightMouseUp())}}),!1),thisCanvas.addEventListener("mousemove",(function(event){const rect=thisCanvas.getBoundingClientRect(),scaleX=thisCanvas.width/rect.width,scaleY=thisCanvas.height/rect.height;thisClass.Mouse.x=(event.clientX-rect.left)*scaleX,thisClass.Mouse.y=(event.clientY-rect.top)*scaleY}),!1),thisCanvas.addEventListener("contextmenu",(function(event){thisClass.ShowContextMenu&&"function"!=typeof thisClass.On.RightMouseDown&&"function"!=typeof thisClass.On.RightMouseUp||event.preventDefault();for(let i=0;i<objects.length;i++)if("function"==typeof objects[i].On.RightMouseDown||"function"==typeof objects[i].On.RightMouseUp){event.preventDefault();break}}),!1)}},LoadImg=function(){for(let i=0;i<arguments.length;i++){const img=new Image;img.onload=function(){img.src=this.src,LoadedImgs.push({img:img,src:arguments[i]})},img.src=arguments[i]}return arguments},LoadSound=function(){for(let i=0;i<arguments.length;i++){const sound=new Audio;sound.onload=function(){sound.src=this.src,LoadedSounds.push({audio:sound,src:arguments[i]})},sound.src=arguments[i]}return arguments},Img=function(src="",x=0,y=0,width=100,height=100){const object={type:"img",img:new Image,x:x,y:y,width:width,height:height,opacity:100,velocityX:0,velocityY:0,gravityXStrength:0,gravityYStrength:0,gravityXEnabled:!1,gravityYEnabled:!1,rotation:0,showBorder:!1,borderWidth:1,borderColor:"#000000",showTopBorder:!1,topBorderWidth:1,topBorderColor:"#000000",showBottomBorder:!1,bottomBorderWidth:1,bottomBorderColor:"#000000",showLeftBorder:!1,leftBorderWidth:1,leftBorderColor:"#000000",showRightBorder:!1,rightBorderWidth:1,rightBorderColor:"#000000",visible:!0,shadowOffsetX:0,shadowOffsetY:0,shadowBlur:0,shadowColor:"#000000",showShadow:!1,hitbox:{topLeft:{x:x-width/2,y:y-height/2},topRight:{x:x+width/2,y:y-height/2},bottomLeft:{x:x-width/2,y:y+height/2},bottomRight:{x:x+width/2,y:y+height/2}},On:{LeftMouseDown:void 0,LeftMouseUp:void 0,RightMouseDown:void 0,RightMouseUp:void 0},SetPosition:function(x=0,y=0){return object.x=x,object.y=y,{x:x,y:y}},GlideTo:function(x=0,y=0,timeInMs=0){const xDist=object.x-x,yDist=object.y-y;let n=0,time0=0;n=xDist>0?xDist:-xDist;for(let i=0;i<n;i++)setTimeout((function(){xDist>0?object.x--:object.x++}),time0),time0+=xDist>0?timeInMs/xDist:timeInMs/-xDist;time0=0,n=yDist>0?yDist:-yDist;for(let i=0;i<n;i++)setTimeout((function(){yDist>0?object.y--:object.y++}),time0),time0+=yDist>0?timeInMs/yDist:timeInMs/-yDist;return{x:x,y:y}},SetBorder:function(width=1,color="#000000"){return object.showBorder=!0,object.borderWidth=width,object.borderColor=color,width+"px "+color},SetShadow:function(offsetX=0,offsetY=0,blur=0,color=""){return object.shadowOffsetX=offsetX,object.shadowOffsetY=offsetY,object.shadowBlur=blur,object.shadowColor=color,object.showShadow=!0,{offsetX:offsetX,offsetY:offsetY,blur:blur,color:color}},PointTowards:function(x=0,y=0){return object.rotation=function getAngle(x1,y1,x2,y2){const distX=x2-x1,distY=y2-y1;return 180*Math.atan2(distY,distX)/Math.PI}(x,y,object.x,object.y)-90,object.rotation}};function getRotatedPos(origin,point,angle){const cos=Math.cos(angle),sin=Math.sin(angle);return{x:cos*(point.x-origin.x)+sin*(point.y-origin.y)+origin.x,y:cos*(point.y-origin.y)-sin*(point.x-origin.x)+origin.y}}return object.img.src=src,function update(){object.type="img",object.gravityXEnabled&&(object.velocityX+=object.gravityXStrength),object.gravityYEnabled&&(object.velocityY+=object.gravityYStrength),object.x+=object.velocityX,object.y+=object.velocityY;const radians=-object.rotation*Math.PI/180;object.hitbox.topLeft=getRotatedPos({x:object.x,y:object.y},{x:object.x-object.width/2,y:object.y-object.height/2},radians),object.hitbox.topRight=getRotatedPos({x:object.x,y:object.y},{x:object.x+object.width/2,y:object.y-object.height/2},radians),object.hitbox.bottomLeft=getRotatedPos({x:object.x,y:object.y},{x:object.x-object.width/2,y:object.y+object.height/2},radians),object.hitbox.bottomRight=getRotatedPos({x:object.x,y:object.y},{x:object.x+object.width/2,y:object.y+object.height/2},radians),requestAnimationFrame(update)}(),object},Line=function(point1=[0,0],point2=[0,0],color=""){const object={type:"line",point1:{x:point1[0],y:point1[1],velocityX:0,velocityY:0,gravityXStrength:0,gravityYStrength:0,gravityXEnabled:!1,gravityYEnabled:!1,SetPosition:function(x=0,y=0){return object.point1.x=x,object.point1.y=y,{x:x,y:y}},GlideTo:function(x=0,y=0,timeInMs=0){const xDist=object.x-x,yDist=object.y-y;let n=0,time0=0;n=xDist>0?xDist:-xDist;for(let i=0;i<n;i++)setTimeout((function(){xDist>0?object.x--:object.x++}),time0),time0+=xDist>0?timeInMs/xDist:timeInMs/-xDist;time0=0,n=yDist>0?yDist:-yDist;for(let i=0;i<n;i++)setTimeout((function(){yDist>0?object.y--:object.y++}),time0),time0+=yDist>0?timeInMs/yDist:timeInMs/-yDist;return{x:x,y:y}}},point2:{x:point2[0],y:point2[1],velocityX:0,velocityY:0,gravityXStrength:0,gravityYStrength:0,gravityXEnabled:!1,gravityYEnabled:!1,SetPosition:function(x=0,y=0){return object.point2.x=x,object.point2.y=y,{x:x,y:y}},GlideTo:function(x=0,y=0,timeInMs=0){const xDist=object.x-x,yDist=object.y-y;let n=0,time0=0;n=xDist>0?xDist:-xDist;for(let i=0;i<n;i++)setTimeout((function(){xDist>0?object.x--:object.x++}),time0),time0+=xDist>0?timeInMs/xDist:timeInMs/-xDist;time0=0,n=yDist>0?yDist:-yDist;for(let i=0;i<n;i++)setTimeout((function(){yDist>0?object.y--:object.y++}),time0),time0+=yDist>0?timeInMs/yDist:timeInMs/-yDist;return{x:x,y:y}}},midPoint:{x:(point1[0]+point2[0])/2,y:(point1[1]+point2[1])/2},color:color,lineWidth:1,length:getDistance(point1[0],point1[1],point2[0],point2[1]),angle:0,opacity:100,visible:!0,shadowOffsetX:0,shadowOffsetY:0,shadowBlur:0,shadowColor:"#000000",showShadow:!1,On:{LeftMouseDown:void 0,LeftMouseUp:void 0,RightMouseDown:void 0,RightMouseUp:void 0},SetShadow:function(offsetX=0,offsetY=0,blur=0,color=""){return object.shadowOffsetX=offsetX,object.shadowOffsetY=offsetY,object.shadowBlur=blur,object.shadowColor=color,object.showShadow=!0,{offsetX:offsetX,offsetY:offsetY,blur:blur,color:color}}};function getDistance(x1,y1,x2,y2){const distX=Math.abs(x1-x2),distY=Math.abs(y1-y2);return Math.sqrt(distX**2+distY**2)}function getAngle(centerX,centerY,endX,endY){const distX=endX-centerX,distY=endY-centerY;return Math.atan2(distY,distX)}return object.angle=getAngle(object.midPoint.x,object.midPoint.y,point2[0],point2[0])/Math.PI*180+90,function update(){object.type="line",object.point1.gravityXEnabled&&(object.point1.velocityX+=object.point1.gravityXStrength),object.point1.gravityYEnabled&&(object.point1.velocityY+=object.point1.gravityYStrength),object.point1.x+=object.point1.velocityX,object.point1.y+=object.point1.velocityY,object.point2.gravityXEnabled&&(object.point2.velocityX+=object.point2.gravityXStrength),object.point2.gravityYEnabled&&(object.point2.velocityY+=object.point2.gravityYStrength),object.point2.x+=object.point2.velocityX,object.point2.y+=object.point2.velocityY,object.length=getDistance(object.point1.x,object.point1.y,object.point2.x,object.point2.y),object.midPoint={x:(object.point1.x+object.point2.x)/2,y:(object.point1.y+object.point2.y)/2},object.angle=getAngle(object.midPoint.x,object.midPoint.y,object.point2.x,object.point2.y)/Math.PI*180+90,requestAnimationFrame(update)}(),object},Polygon=function(){const object={type:"polygon",x:void 0,y:void 0,points:[],sides:[],color:arguments[arguments.length-1],opacity:100,velocityX:0,velocityY:0,gravityXStrength:0,gravityYStrength:0,gravityXEnabled:!1,gravityYEnabled:!1,lineWidth:1,stroke:!1,rotation:0,showBorder:!1,borderWidth:1,borderColor:"#000000",visible:!0,shadowOffsetX:0,shadowOffsetY:0,shadowBlur:0,shadowColor:"#000000",showShadow:!1,On:{LeftMouseDown:void 0,LeftMouseUp:void 0,RightMouseDown:void 0,RightMouseUp:void 0},SetShadow:function(offsetX=0,offsetY=0,blur=0,color=""){return object.shadowOffsetX=offsetX,object.shadowOffsetY=offsetY,object.shadowBlur=blur,object.shadowColor=color,object.showShadow=!0,{offsetX:offsetX,offsetY:offsetY,blur:blur,color:color}},SetPosition:function(x=0,y=0){return object.x=x,object.y=y,{x:x,y:y}},GlideTo:function(x=0,y=0,timeInMs=0){const xDist=object.x-x,yDist=object.y-y;let n=0,time0=0;n=xDist>0?xDist:-xDist;for(let i=0;i<n;i++)setTimeout((function(){xDist>0?object.x--:object.x++}),time0),time0+=xDist>0?timeInMs/xDist:timeInMs/-xDist;time0=0,n=yDist>0?yDist:-yDist;for(let i=0;i<n;i++)setTimeout((function(){yDist>0?object.y--:object.y++}),time0),time0+=yDist>0?timeInMs/yDist:timeInMs/-yDist;return{x:x,y:y}},SetBorder:function(width=1,color="#000000"){return object.showBorder=!0,object.borderWidth=width,object.borderColor=color,width+"px "+color},PointTowards:function(x=0,y=0){return object.rotation=function getAngle(x1,y1,x2,y2){const distX=x2-x1,distY=y2-y1;return 180*Math.atan2(distY,distX)/Math.PI}(x,y,object.x,object.y)-90,object.rotation}};for(let i=0;i<arguments.length-1;i++){const point={x:arguments[i][0],y:arguments[i][1],offsetX:void 0,offsetY:void 0,SetX:function(x=0){return point.offsetX=x-object.x,x},SetY:function(y=0){return point.offsetY=y-object.y,y},SetPosition:function(x=0,y=0){return point.offsetX=x-object.x,point.offsetY=y-object.y,{x:x,y:y}},GlideTo:function(x=0,y=0,timeInMs=0){const xDist=point.x-x,yDist=point.y-y;let n=0,time0=0;n=xDist>0?xDist:-xDist;for(let i=0;i<n;i++)setTimeout((function(){xDist>0?point.offsetX--:point.offsetX++}),time0),time0+=xDist>0?timeInMs/xDist:timeInMs/-xDist;time0=0,n=yDist>0?yDist:-yDist;for(let i=0;i<n;i++)setTimeout((function(){yDist>0?point.offsetY--:point.offsetY++}),time0),time0+=yDist>0?timeInMs/yDist:timeInMs/-yDist;return{x:x,y:y}},SetOffsetX:function(offsetX=0){return point.offsetX=offsetX,offsetX},SetOffsetY:function(offsetY=0){return point.offsetY=offsetY,offsetY},SetOffset:function(offsetX=0,offsetY=0){return point.offsetX=offsetX,point.offsetY=offsetY,{offsetX:offsetX,offsetY:offsetY}}};object.points.push(point)}return function setup(){const points=object.points;let totalX=0,totalY=0;for(let i=0;i<points.length;i++)totalX+=points[i].x,totalY+=points[i].y;object.x=totalX/points.length,object.y=totalY/points.length;for(let i=0;i<points.length;i++)points[i].offsetX=points[i].x-object.x,points[i].offsetY=points[i].y-object.y}(),function update(){object.type="polygon";const points=object.points,sides=[];for(let i=0;i<points.length;i++){let side;points[i].x=object.x+points[i].offsetX,points[i].y=object.y+points[i].offsetY,side=i+1<points.length?{point1:points[i],point2:points[i+1]}:{point1:points[i],point2:points[0]},sides.push(side)}JSON.stringify(object.sides)!=JSON.stringify(sides)&&(object.sides=sides),object.gravityXEnabled&&(object.velocityX+=object.gravityXStrength),object.gravityYEnabled&&(object.velocityY+=object.gravityYStrength),object.x+=object.velocityX,object.y+=object.velocityY,requestAnimationFrame(update)}(),object},Rect=function(x=0,y=0,width=100,height=100,color="#000000"){const object={type:"rect",x:x,y:y,width:width,height:height,color:color,velocityX:0,velocityY:0,gravityXStrength:0,gravityYStrength:0,gravityXEnabled:!1,gravityYEnabled:!1,lineWidth:1,stroke:!1,rotation:0,opacity:100,showBorder:!1,borderWidth:1,borderColor:"#000000",showTopBorder:!1,topBorderWidth:1,topBorderColor:"#000000",showBottomBorder:!1,bottomBorderWidth:1,bottomBorderColor:"#000000",showLeftBorder:!1,leftBorderWidth:1,leftBorderColor:"#000000",showRightBorder:!1,rightBorderWidth:1,rightBorderColor:"#000000",shadowOffsetX:0,shadowOffsetY:0,shadowBlur:0,shadowColor:"#000000",showShadow:!1,visible:!0,hitbox:{topLeft:{x:x-width/2,y:y-height/2},topRight:{x:x+width/2,y:y-height/2},bottomLeft:{x:x-width/2,y:y+height/2},bottomRight:{x:x+width/2,y:y+height/2}},On:{LeftMouseDown:void 0,LeftMouseUp:void 0,RightMouseDown:void 0,RightMouseUp:void 0},SetPosition:function(x=0,y=0){return object.x=x,object.y=y,{x:x,y:y}},GlideTo:function(x=0,y=0,timeInMs=0){const xDist=object.x-x,yDist=object.y-y;let n=0,time0=0;n=xDist>0?xDist:-xDist;for(let i=0;i<n;i++)setTimeout((function(){xDist>0?object.x--:object.x++}),time0),time0+=xDist>0?timeInMs/xDist:timeInMs/-xDist;time0=0,n=yDist>0?yDist:-yDist;for(let i=0;i<n;i++)setTimeout((function(){yDist>0?object.y--:object.y++}),time0),time0+=yDist>0?timeInMs/yDist:timeInMs/-yDist;return{x:x,y:y}},SetBorder:function(width=1,color="#000000"){return object.showBorder=!0,object.borderWidth=width,object.borderColor=color,{width:width,color:color}},SetTopBorder:function(width=1,color="#000000"){return object.showTopBorder=!0,object.topBorderWidth=width,object.topBorderColor=color,{width:width,color:color}},SetBottomBorder:function(width=1,color="#000000"){return object.showBottomBorder=!0,object.bottomBorderWidth=width,object.bottomBorderColor=color,{width:width,color:color}},SetLeftBorder:function(width=1,color="#000000"){return object.showLeftBorder=!0,object.leftBorderWidth=width,object.leftBorderColor=color,{width:width,color:color}},SetRightBorder:function(width=1,color="#000000"){return object.showRightBorder=!0,object.rightBorderWidth=width,object.rightBorderColor=color,{width:width,color:color}},SetShadow:function(offsetX=0,offsetY=0,blur=0,color=""){return object.shadowOffsetX=offsetX,object.shadowOffsetY=offsetY,object.shadowBlur=blur,object.shadowColor=color,object.showShadow=!0,{offsetX:offsetX,offsetY:offsetY,blur:blur,color:color}},PointTowards:function(x=0,y=0){return object.rotation=function getAngle(x1,y1,x2,y2){const distX=x2-x1,distY=y2-y1;return 180*Math.atan2(distY,distX)/Math.PI}(x,y,object.x,object.y)-90,object.rotation}};function getRotatedPos(origin,point,angle){return{x:Math.cos(angle)*(point.x-origin.x)+Math.sin(angle)*(point.y-origin.y)+origin.x,y:Math.cos(angle)*(point.y-origin.y)-Math.sin(angle)*(point.x-origin.x)+origin.y}}return function update(){object.type="rect",object.gravityXEnabled&&(object.velocityX+=object.gravityXStrength),object.gravityYEnabled&&(object.velocityY+=object.gravityYStrength),object.x+=object.velocityX,object.y+=object.velocityY;const radians=-object.rotation*Math.PI/180;object.hitbox.topLeft=getRotatedPos({x:object.x,y:object.y},{x:object.x-object.width/2,y:object.y-object.height/2},radians),object.hitbox.topRight=getRotatedPos({x:object.x,y:object.y},{x:object.x+object.width/2,y:object.y-object.height/2},radians),object.hitbox.bottomLeft=getRotatedPos({x:object.x,y:object.y},{x:object.x-object.width/2,y:object.y+object.height/2},radians),object.hitbox.bottomRight=getRotatedPos({x:object.x,y:object.y},{x:object.x+object.width/2,y:object.y+object.height/2},radians),requestAnimationFrame(update)}(),object},Circle=function(x=0,y=0,radius=50,color="#000000"){const object={type:"circle",x:x,y:y,radius:radius,color:color,velocityX:0,velocityY:0,gravityXStrength:0,gravityYStrength:0,gravityXEnabled:!1,gravityYEnabled:!1,lineWidth:1,stroke:!1,opacity:100,showBorder:!1,borderWidth:1,borderColor:"#000000",visible:!0,shadowOffsetX:0,shadowOffsetY:0,shadowBlur:0,shadowColor:"#000000",showShadow:!1,On:{LeftMouseDown:void 0,LeftMouseUp:void 0,RightMouseDown:void 0,RightMouseUp:void 0},SetShadow:function(offsetX=0,offsetY=0,blur=0,color=""){return object.shadowOffsetX=offsetX,object.shadowOffsetY=offsetY,object.shadowBlur=blur,object.shadowColor=color,object.showShadow=!0,{offsetX:offsetX,offsetY:offsetY,blur:blur,color:color}},SetPosition:function(x=0,y=0){return object.x=x,object.y=y,{x:x,y:y}},GlideTo:function(x=0,y=0,timeInMs=0){const xDist=object.x-x,yDist=object.y-y;let n=0,time0=0;n=xDist>0?xDist:-xDist;for(let i=0;i<n;i++)setTimeout((function(){xDist>0?object.x--:object.x++}),time0),time0+=xDist>0?timeInMs/xDist:timeInMs/-xDist;time0=0,n=yDist>0?yDist:-yDist;for(let i=0;i<n;i++)setTimeout((function(){yDist>0?object.y--:object.y++}),time0),time0+=yDist>0?timeInMs/yDist:timeInMs/-yDist;return{x:x,y:y}},SetBorder:function(width=0,color=""){return object.showBorder=!0,object.borderWidth=width,object.borderColor=color,width+"px "+color}};return function update(){object.type="circle",object.gravityXEnabled&&(object.velocityX+=object.gravityXStrength),object.gravityYEnabled&&(object.velocityY+=object.gravityYStrength),object.x+=object.velocityX,object.y+=object.velocityY,requestAnimationFrame(update)}(),object},Square=function(x=0,y=0,size=100,color="#000000"){return Rect(x,y,size,size,color)},Text=function(text="",fontSize=20,font="",x=0,y=0,color="#000000"){const object={type:"text",text:text,font:font,fontSize:fontSize,x:x,y:y,color:color,opacity:100,velocityX:0,velocityY:0,gravityXStrength:0,gravityYStrength:0,gravityXEnabled:!1,gravityYEnabled:!1,rotation:0,visible:!0,shadowOffsetX:0,shadowOffsetY:0,shadowBlur:0,shadowColor:"#000000",showShadow:!1,SetShadow:function(offsetX=0,offsetY=0,blur=0,color=""){return object.shadowOffsetX=offsetX,object.shadowOffsetY=offsetY,object.shadowBlur=blur,object.shadowColor=color,object.showShadow=!0,{offsetX:offsetX,offsetY:offsetY,blur:blur,color:color}},SetPosition:function(x=0,y=0){return object.x=x,object.y=y,{x:x,y:y}},GlideTo:function(x=0,y=0,timeInMs=0){const xDist=object.x-x,yDist=object.y-y;let n=0,time0=0;n=xDist>0?xDist:-xDist;for(let i=0;i<n;i++)setTimeout((function(){xDist>0?object.x--:object.x++}),time0),time0+=xDist>0?timeInMs/xDist:timeInMs/-xDist;time0=0,n=yDist>0?yDist:-yDist;for(let i=0;i<n;i++)setTimeout((function(){yDist>0?object.y--:object.y++}),time0),time0+=yDist>0?timeInMs/yDist:timeInMs/-yDist;return{x:x,y:y}},PointTowards:function(x=0,y=0){return object.rotation=function getAngle(x1,y1,x2,y2){const distX=x2-x1,distY=y2-y1;return 180*Math.atan2(distY,distX)/Math.PI}(x,y,object.x,object.y)-90,object.rotation}};return function update(){object.type="text",object.gravityXEnabled&&(object.velocityX+=object.gravityXStrength),object.gravityYEnabled&&(object.velocityY+=object.gravityYStrength),object.x+=object.velocityX,object.y+=object.velocityY,requestAnimationFrame(update)}(),object},CustomObject=function(func=new Function){const object={type:"custom",Draw:func};return 0==arguments.length&&(object.Draw=void 0),object},PlaySound=function(src=""){let sound;for(let i=0;i<LoadedSounds.length;i++)LoadedSounds[i].audio.pause(),LoadedSounds[i].src==src&&(sound=LoadedSounds[i]);sound.audio.play()},IsColliding=function(object1={},object2={}){function getRotatedPos(origin,point,angle){return{x:Math.cos(angle)*(point.x-origin.x)+Math.sin(angle)*(point.y-origin.y)+origin.x,y:Math.cos(angle)*(point.y-origin.y)-Math.sin(angle)*(point.x-origin.x)+origin.y}}function getAngle(centerX,centerY,endX,endY){const distX=endX-centerX,distY=endY-centerY;return Math.atan2(distY,distX)}function checkLines(line1,line2){const line=((line2.point2.x-line2.point1.x)*(line1.point1.y-line2.point1.y)-(line2.point2.y-line2.point1.y)*(line1.point1.x-line2.point1.x))/((line2.point2.y-line2.point1.y)*(line1.point2.x-line1.point1.x)-(line2.point2.x-line2.point1.x)*(line1.point2.y-line1.point1.y)),line0=((line1.point2.x-line1.point1.x)*(line1.point1.y-line2.point1.y)-(line1.point2.y-line1.point1.y)*(line1.point1.x-line2.point1.x))/((line2.point2.y-line2.point1.y)*(line1.point2.x-line1.point1.x)-(line2.point2.x-line2.point1.x)*(line1.point2.y-line1.point1.y));return line>=0&&line<=1&&line0>=0&&line0<=1}function getRectFromLine(point1,point2,midX,midY,lineWidth,radians){const origin={x:midX,y:midY},newPoint1=getRotatedPos(origin,point1,radians),newPoint2=getRotatedPos(origin,point2,radians),width=Math.abs(newPoint1.x-newPoint2.x),height=lineWidth,topLeft=getRotatedPos(origin,{x:newPoint1.x,y:newPoint1.y-height/2},-radians),topRight=getRotatedPos(origin,{x:newPoint2.x,y:newPoint2.y-height/2},-radians),bottomLeft=getRotatedPos(origin,{x:newPoint1.x,y:newPoint1.y+height/2},-radians),bottomRight=getRotatedPos(origin,{x:newPoint2.x,y:newPoint2.y+height/2},-radians);return{x:newPoint1.x,y:newPoint1.y-height/2,width:width,height:height,points:[topLeft,topRight,bottomLeft,bottomRight],sides:[{point1:topLeft,point2:topRight},{point1:bottomLeft,point2:bottomRight},{point1:topLeft,point2:bottomLeft},{point1:topRight,point2:bottomRight}]}}function checkPolygonPoint(points,point){let collision=!1,next=0;for(let current=0;current<points.length;current++){next=current+1,next==points.length&&(next=0);const currentPoint=points[current],nextPoint=points[next];(currentPoint.y>=point.y&&nextPoint.y<point.y||currentPoint.y<point.y&&nextPoint.y>=point.y)&&point.x<(nextPoint.x-currentPoint.x)*(point.y-currentPoint.y)/(nextPoint.y-currentPoint.y)+currentPoint.x&&(collision=!collision)}return collision}function checkLineCircle(point1,point2,circle){const x=circle.x,y=circle.y,radius=circle.radius,distX=point2.x-point1.x,distY=point2.y-point1.y,u=Math.min(1,Math.max(0,((x-point1.x)*distX+(y-point1.y)*distY)/(distY*distY+distX*distX))),closestX=point1.x+distX*u-x,closestY=point1.y+distY*u-y;return closestX*closestX+closestY*closestY<radius*radius}if(object1 instanceof Array&&object2 instanceof Array){const point1={x:object1[0],y:object1[1]},point2={x:object2[0],y:object2[1]};return point1.x==point2.x&&point1.y==point2.y}if(object1 instanceof Array&&("rect"==object2.type||"img"==object2.type)||("rect"==object1.type||"img"==object1.type)&&object2 instanceof Array){let point,rect;object1 instanceof Array?(point={x:object1[0],y:object1[1]},rect=object2):(point={x:object2[0],y:object2[1]},rect=object1);const origin={x:rect.x,y:rect.y},radians=rect.rotation*Math.PI/180,rectX=rect.x-rect.width/2,rectY=rect.y-rect.height/2,newPoint=getRotatedPos(origin,point,radians);return newPoint.x>rectX&&newPoint.x<rectX+rect.width&&newPoint.y>rectY&&newPoint.y<rectY+rect.height}if(object1 instanceof Array&&"circle"==object2.type||"circle"==object1.type&&object2 instanceof Array){let point,circle;object1 instanceof Array?(point={x:object1[0],y:object1[1]},circle=object2):(point={x:object2[0],y:object2[1]},circle=object1);return function getDist(x1,y1,x2,y2){const distX=Math.abs(x1-x2),distY=Math.abs(y1-y2);return Math.sqrt(distX**2+distY**2)}(point.x,point.y,circle.x,circle.y)<circle.radius}if(object1 instanceof Array&&"polygon"==object2.type||"polygon"==object1.type&&object2 instanceof Array){let point,polygon;object1 instanceof Array?(point={x:object1[0],y:object1[1]},polygon=object2):(point={x:object2[0],y:object2[1]},polygon=object1);const newPoints=[],radians=polygon.rotation*Math.PI/180;for(let i=0;i<polygon.points.length;i++){const newPoint=getRotatedPos(polygon,polygon.points[i],-radians);newPoints.push(newPoint)}return checkPolygonPoint(newPoints,point)}if(object1 instanceof Array&&"line"==object2.type||"line"==object1.type&&object2 instanceof Array){let point,line;object1 instanceof Array?(point={x:object1[0],y:object1[1]},line=object2):(point={x:object2[0],y:object2[1]},line=object1);const point1=line.point1,point2=line.point2,midPoint=function getMidPoint(x1,y1,x2,y2){return{x:(x1+x2)/2,y:(y1+y2)/2}}(point1.x,point1.y,point2.x,point2.y),radians=getAngle(midPoint.x,midPoint.y,point2.x,point2.y),rect=getRectFromLine(point1,point2,midPoint.x,midPoint.y,line.lineWidth,radians),newPoint=getRotatedPos({x:rect.x+rect.width/2,y:rect.y+rect.height/2},point,radians);return newPoint.x>rect.x&&newPoint.x<rect.x+rect.width&&newPoint.y>rect.y&&newPoint.y<rect.y+rect.height}if("circle"==object1.type&&"line"==object2.type||"line"==object1.type&&"circle"==object2.type){let circle,line;"circle"==object1.type?(circle=object1,line=object2):(circle=object2,line=object1);const point1=line.point1,point2=line.point2,midX=(point1.x+point2.x)/2,midY=(point1.y+point2.y)/2,lineWidth=line.lineWidth;let radians=getAngle(midX,midY,point2.x,point2.y);const rect=getRectFromLine(point1,point2,midX,midY,lineWidth,radians),newPoint=getRotatedPos({x:midX,y:midY},{x:circle.x,y:circle.y},radians);let closestX,closestY;closestX=newPoint.x<rect.x?rect.x:newPoint.x>rect.x+rect.width?rect.x+rect.width:newPoint.x,closestY=newPoint.y<rect.y?rect.y:newPoint.y>rect.y+rect.height?rect.y+rect.height:newPoint.y;const distX=Math.abs(newPoint.x-closestX),distY=Math.abs(newPoint.y-closestY);return Math.sqrt(distX**2+distY**2)<circle.radius}if(("rect"==object1.type||"img"==object1.type)&&"line"==object2.type||"line"==object1.type&&("rect"==object2.type||"img"==object2.type)){let rect,line;"line"==object1.type?(line=object1,rect=object2):(line=object2,rect=object1);const point1=line.point1,point2=line.point2,midX=(point1.x+point2.x)/2,midY=(point1.y+point2.y)/2,lineWidth=line.lineWidth;let radians=getAngle(midX,midY,point2.x,point2.y);const rectFromLine=getRectFromLine(point1,point2,midX,midY,lineWidth,radians),points=[rect.hitbox.topLeft,rect.hitbox.topRight,rect.hitbox.bottomLeft,rect.hitbox.bottomRight],sides=[{point1:rect.hitbox.topLeft,point2:rect.hitbox.topRight},{point1:rect.hitbox.bottomLeft,point2:rect.hitbox.bottomRight},{point1:rect.hitbox.topLeft,point2:rect.hitbox.bottomLeft},{point1:rect.hitbox.topRight,point2:rect.hitbox.bottomRight}];for(let i=0;i<rectFromLine.points.length;i++){const points=rectFromLine.points,newPoint=getRotatedPos(origin,{x:points[i].x,y:points[i].y},radians),rectX=rect.x-rect.width/2,rectY=rect.y-rect.height/2;if(newPoint.x>rectX&&newPoint.x<rectX+rect.width&&newPoint.y>rectY&&newPoint.y<rectY+rect.height)return!0}radians=rect.rotation*Math.PI/180;for(let i=0;i<points.length;i++){const newPoint=getRotatedPos(origin,{x:points[i].x,y:points[i].y},radians);if(newPoint.x>rectFromLine.x&&newPoint.x<rectFromLine.x+rectFromLine.width&&newPoint.y>rectFromLine.y&&newPoint.y<rectFromLine.y+rectFromLine.height)return!0}for(let i=0;i<rectFromLine.sides.length;i++)for(let x=0;x<sides.length;x++)if(checkLines(rectFromLine.sides[i],sides[x]))return!0;return!1}if("line"==object1.type&&"line"==object2.type){let point1=object1.point1,point2=object1.point2,midX=(point1.x+point2.x)/2,midY=(point1.y+point2.y)/2,lineWidth=object1.lineWidth;const origin1={x:midX,y:midY},radians1=getAngle(midX,midY,point2.x,point2.y),rect1=getRectFromLine(point1,point2,midX,midY,lineWidth,radians1);point1=object2.point1,point2=object2.point2,midX=(point1.x+point2.x)/2,midY=(point1.y+point2.y)/2,lineWidth=object2.lineWidth;const origin2={x:midX,y:midY},radians2=getAngle(midX,midY,point2.x,point2.y),rect2=getRectFromLine(point1,point2,midX,midY,lineWidth,radians2);for(let i=0;i<rect1.points.length;i++){const points=rect1.points,newPoint=getRotatedPos(origin2,{x:points[i].x,y:points[i].y},radians2);if(newPoint.x>rect2.x&&newPoint.x<rect2.x+rect2.width&&newPoint.y>rect2.y&&newPoint.y<rect2.y+rect2.height)return!0}for(let i=0;i<rect2.points.length;i++){const points=rect2.points,newPoint=getRotatedPos(origin1,{x:points[i].x,y:points[i].y},radians1);if(newPoint.x>rect1.x&&newPoint.x<rect1.x+rect1.width&&newPoint.y>rect1.y&&newPoint.y<rect1.y+rect1.height)return!0}for(let i=0;i<rect1.sides.length;i++)for(let x=0;x<rect2.sides.length;x++)if(checkLines(rect1.sides[i],rect2.sides[x]))return!0;return!1}if(!("rect"!=object1.type&&"img"!=object1.type||"rect"!=object2.type&&"img"!=object2.type)){const sides=[{point1:object1.hitbox.topLeft,point2:object1.hitbox.topRight},{point1:object1.hitbox.bottomLeft,point2:object1.hitbox.bottomRight},{point1:object1.hitbox.topLeft,point2:object1.hitbox.bottomLeft},{point1:object1.hitbox.topRight,point2:object1.hitbox.bottomRight}],sides0=[{point1:object2.hitbox.topLeft,point2:object2.hitbox.topRight},{point1:object2.hitbox.bottomLeft,point2:object2.hitbox.bottomRight},{point1:object2.hitbox.topLeft,point2:object2.hitbox.bottomLeft},{point1:object2.hitbox.topRight,point2:object2.hitbox.bottomRight}];let radians=object1.rotation*Math.PI/180,origin={x:object1.x,y:object1.y},points=[object2.hitbox.topLeft,object2.hitbox.topRight,object2.hitbox.bottomLeft,object2.hitbox.bottomRight];for(let i=0;i<points.length;i++){const newPoint=getRotatedPos(origin,{x:points[i].x,y:points[i].y},radians),rectX=object1.x-object1.width/2,rectY=object1.y-object1.height/2;if(newPoint.x>rectX&&newPoint.x<rectX+object1.width&&newPoint.y>rectY&&newPoint.y<rectY+object1.height)return!0}radians=object2.rotation*Math.PI/180,origin={x:object2.x,y:object2.y},points=[object1.hitbox.topLeft,object1.hitbox.topRight,object1.hitbox.bottomLeft,object1.hitbox.bottomRight];for(let i=0;i<points.length;i++){const newPoint=getRotatedPos(origin,{x:points[i].x,y:points[i].y},radians),rectX=object2.x-object2.width/2,rectY=object2.y-object2.height/2;if(newPoint.x>rectX&&newPoint.x<rectX+object2.width&&newPoint.y>rectY&&newPoint.y<rectY+object2.height)return!0}for(let i=0;i<sides.length;i++)for(let x=0;x<sides0.length;x++)if(checkLines(sides[i],sides0[x]))return!0;return!1}if("circle"==object1.type&&"circle"==object2.type){const distX=Math.abs(object1.x-object2.x),distY=Math.abs(object1.y-object2.y);return Math.sqrt(distX^2+distY^2)<object1.radius+object2.radius}if(("rect"==object1.type||"img"==object1.type)&&"circle"==object2.type||"circle"==object1.type&&("rect"==object2.type||"img"==object2.type)){let rect,circle;"rect"==object1.type||"img"==object1.type?(rect=object1,circle=object2):(rect=object2,circle=object1);const radians=rect.rotation*Math.PI/180,rectX=rect.x-rect.width/2,rectY=rect.y-rect.height/2,newPoint=getRotatedPos(rect,circle,radians);let closestX,closestY;closestX=newPoint.x<rectX?rectX:newPoint.x>rectX+rect.width?rectX+rect.width:newPoint.x,closestY=newPoint.y<rectY?rectY:newPoint.y>rectY+rect.height?rectY+rect.height:newPoint.y;const distX=Math.abs(newPoint.x-closestX),distY=Math.abs(newPoint.y-closestY);return Math.sqrt(distX**2+distY**2)<circle.radius}if("polygon"==object1.type&&"circle"==object2.type||"circle"==object1.type&&"polygon"==object2.type){let polygon,circle;"polygon"==object1.type?(polygon=object1,circle=object2):(polygon=object2,circle=object1);const points=[],sides=[],radians=polygon.rotation*Math.PI/180;for(let i=0;i<polygon.points.length;i++){const newPoint=getRotatedPos(polygon,polygon.points[i],-radians);points.push(newPoint)}for(let i=0;i<polygon.sides.length;i++){const newPoint1=getRotatedPos(polygon,polygon.sides[i].point1,-radians),newPoint2=getRotatedPos(polygon,polygon.sides[i].point2,-radians);sides.push({point1:newPoint1,point2:newPoint2})}for(let i=0;i<sides.length;i++)if(checkLineCircle(sides[i].point1,sides[i].point2,circle))return!0;return!!checkPolygonPoint(points,circle)}if("polygon"==object1.type&&"polygon"==object2.type){const points1=[],points2=[],sides1=[],sides2=[];let radians=object1.rotation*Math.PI/180;for(let i=0;i<object1.points.length;i++){const newPoint=getRotatedPos(object1,object1.points[i],-radians);points1.push(newPoint)}for(let i=0;i<object1.sides.length;i++){const newPoint1=getRotatedPos(object1,object1.sides[i].point1,-radians),newPoint2=getRotatedPos(object1,object1.sides[i].point2,-radians);sides1.push({point1:newPoint1,point2:newPoint2})}radians=object2.rotation*Math.PI/180;for(let i=0;i<object2.points.length;i++){const newPoint=getRotatedPos(object2,object2.points[i],-radians);points2.push(newPoint)}for(let i=0;i<object2.sides.length;i++){const newPoint1=getRotatedPos(object2,object2.sides[i].point1,-radians),newPoint2=getRotatedPos(object2,object2.sides[i].point2,-radians);sides2.push({point1:newPoint1,point2:newPoint2})}for(let i=0;i<points1.length;i++)if(checkPolygonPoint(points2,points1[i]))return!0;for(let i=0;i<points2.length;i++)if(checkPolygonPoint(points1,points2[i]))return!0;for(let i=0;i<sides1.length;i++)for(let j=0;j<sides2.length;j++)if(checkLines(sides1[i],sides2[j]))return!0;return!1}if(("rect"==object1.type||"img"==object1.type)&&"polygon"==object2.type||"polygon"==object1.type&&("rect"==object2.type||"img"==object2.type)){let rect,polygon;"rect"==object1.type?(rect=object1,polygon=object2):(rect=object2,polygon=object1);const sides1=[{point1:rect.hitbox.topLeft,point2:rect.hitbox.topRight},{point1:rect.hitbox.bottomLeft,point2:rect.hitbox.bottomRight},{point1:rect.hitbox.topLeft,point2:rect.hitbox.bottomLeft},{point1:rect.hitbox.topRight,point2:rect.hitbox.bottomRight}],sides2=[],points1=[rect.hitbox.topLeft,rect.hitbox.topRight,rect.hitbox.bottomLeft,rect.hitbox.bottomRight],points2=[];let radians=polygon.rotation*Math.PI/180;for(let i=0;i<polygon.sides.length;i++){const newPoint1=getRotatedPos(polygon,polygon.sides[i].point1,-radians),newPoint2=getRotatedPos(polygon,polygon.sides[i].point2,-radians);sides2.push({point1:newPoint1,point2:newPoint2})}for(let i=0;i<sides1.length;i++)for(let j=0;j<sides2.length;j++)if(checkLines(sides1[i],sides2[j]))return!0;for(let i=0;i<polygon.points.length;i++){const point=getRotatedPos(polygon,polygon.points[i],-radians);points2.push(point)}for(let i=0;i<points1.length;i++)if(checkPolygonPoint(points2,points1[i]))return!0;const rectX=rect.x-rect.width/2,rectY=rect.y-rect.height/2;radians=rect.rotation*Math.PI/180;for(let i=0;i<points2.length;i++){const newPoint=getRotatedPos(rect,points2[i],radians);if(newPoint.x>rectX&&newPoint.x<rectX+rect.width&&newPoint.y>rectY&&newPoint.y<rectY+rect.height)return!0}return!1}if("polygon"==object1.type&&"line"==object2.type||"line"==object1.type&&"polygon"==object2.type){let polygon,line;"polygon"==object1.type?(polygon=object1,line=object2):(polygon=object2,line=object1);const point1=line.point1,point2=line.point2,midX=(point1.x+point2.x)/2,midY=(point1.y+point2.y)/2,lineWidth=line.lineWidth,radians1=getAngle(midX,midY,point2.x,point2.y),rect=getRectFromLine(point1,point2,midX,midY,lineWidth,radians1),points1=[],points2=rect.points,sides1=[],sides2=rect.sides,radians2=polygon.rotation*Math.PI/180;for(let i=0;i<polygon.points.length;i++){const newPoint=getRotatedPos(polygon,polygon.points[i],-radians2);points1.push(newPoint)}for(let i=0;i<polygon.sides.length;i++){const newPoint1=getRotatedPos(polygon,polygon.sides[i].point1,-radians2),newPoint2=getRotatedPos(polygon,polygon.sides[i].point2,-radians2);sides1.push({point1:newPoint1,point2:newPoint2})}for(let i=0;i<points1.length;i++){const newPoint=getRotatedPos({x:midX,y:midY},points1[i],radians1);if(newPoint.x>rect.x&&newPoint.x<rect.x+rect.width&&newPoint.y>rect.y&&newPoint.y<rect.y+rect.height)return!0}for(let i=0;i<points2.length;i++)if(checkPolygonPoint(points1,points2[i]))return!0;for(let i=0;i<sides1.length;i++)for(let j=0;j<sides2.length;j++)if(checkLines(sides1[i],sides2[j]))return!0;return!1}},Loop=function(func=new Function,timeInMs=undefined){if(null==timeInMs){function loop(){"function"==typeof func&&func(),"function"==typeof loop&&requestAnimationFrame(loop)}return loop(),{ClearLoop:function(){loop=void 0}}}{"function"==typeof func&&func();const loop=setInterval((function(){"function"==typeof func&&func()}),timeInMs);return{ClearLoop:function(){clearInterval(loop)}}}},Repeat=function(func=new Function,num=0){let i;for(num=Math.round(num),i=0;i<num;i++)"function"==typeof func&&func();return{Stop:function(){i=num}}},After=function(timeInMs=0,func=new Function){return"function"==typeof func&&setTimeout(func,timeInMs),timeInMs},RandomInt=function(minimum=0,maximum=1){if(minimum>=0)return Math.floor(Math.random()*(maximum-minimum+1)+minimum);if(minimum<0&&maximum>=0){const x=Math.abs(minimum);return Math.floor(Math.random()*(maximum+x+1))-x}{const min=Math.abs(minimum),max=Math.abs(maximum);return-(Math.floor(Math.random()*max-min+1)+min)}},GetDistance=function(point1=[0,0],point2=[0,0]){const x1=point1[0],y1=point1[1],x2=point2[0],y2=point2[1],distX=Math.abs(x2-x1),distY=Math.abs(y2-y1);return Math.sqrt(distX**2+distY**2)},GetMidPoint=function(point1=[0,0],point2=[0,0]){const x1=point1[0],y1=point1[1];return{x:(x1+point2[0])/2,y:(y1+point2[1])/2}},GetAngle=function(midPoint=[0,0],point=[0,0]){const x1=midPoint[0],y1=midPoint[1],distX=point[0]-x1,distY=point[1]-y1;return 180*Math.atan2(distY,distX)/Math.PI-90},DegreesToRadians=function(degrees=0){return degrees*Math.PI/180},RadiansToDegrees=function(radians=0){return radians/180*Math.PI},GetRotatedPosition=function(origin=[0,0],point=[0,0],degrees=0){const originX=origin[0],originY=origin[1],pointX=point[0],pointY=point[1],radians=degrees*Math.PI/180;return{x:Math.cos(-radians)*(pointX-originX)+Math.sin(-radians)*(pointY-originY)+originX,y:Math.cos(-radians)*(pointY-originY)-Math.sin(-radians)*(pointX-originX)+originY}};document.addEventListener("keydown",(function(event){KeysPressed[event.code]=!0}),!1),document.addEventListener("keyup",(function(event){KeysPressed[event.code]=!1}),!1),document.addEventListener("mousedown",(function(event){let browser,leftMouse=1,mouseWheel=2,rightMouse=3;if("which"in event)browser="which";else{if(!("button"in event))return void console.error("'event.which' and 'event.button' are unsupported in this browser.");browser="button",leftMouse--,mouseWheel--,rightMouse--}event[browser]==leftMouse?(LeftMouseDown=!0,"function"==typeof On.LeftMouseDown&&On.LeftMouseDown()):event[browser]==mouseWheel?(MouseWheelDown=!0,"function"==typeof On.MouseWheelDown&&(event.preventDefault(),On.MouseWheelDown())):event[browser]==rightMouse&&(RightMouseDown=!0,"function"==typeof On.RightMouseDown&&On.RightMouseDown())}),!1),document.addEventListener("mouseup",(function(event){let browser,leftMouse=1,mouseWheel=2,rightMouse=3;if("which"in event)browser="which";else{if(!("button"in event))return void console.error("'event.which' and 'event.button' are unsupported in this browser.");browser="button",leftMouse--,mouseWheel--,rightMouse--}event[browser]==leftMouse?(LeftMouseDown=!1,"function"==typeof On.LeftMouseUp&&On.LeftMouseUp()):event[browser]==mouseWheel?(MouseWheelDown=!1,"function"==typeof On.MouseWheelUp&&(event.preventDefault(),On.MouseWheelUp())):event[browser]==rightMouse&&(RightMouseDown=!1,"function"==typeof On.RightMouseUp&&On.RightMouseUp())}),!1),document.addEventListener("mousemove",(function(event){Mouse.x=event.clientX,Mouse.y=event.clientY}),!1),document.addEventListener("contextmenu",(function(event){ShowContextMenu&&"function"!=typeof On.RightMouseDown&&"function"!=typeof On.RightMouseUp||event.preventDefault()}),!1),function(){let previousTime=Date.now();requestAnimationFrame((function loop(){const currentTime=Date.now();FPS=Math.round(1e3/(currentTime-previousTime)),ExactFPS=1e3/(currentTime-previousTime),previousTime=currentTime,requestAnimationFrame(loop)}))}(),console.log("Using 2dev.js Version 2"),console.log("GitHub: https://github.com/masgalascharles/2dev.js");
