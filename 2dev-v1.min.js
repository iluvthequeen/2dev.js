const K_BACKSPACE="Backspace",K_TAB="Tab",K_ENTER="Enter",K_SHIFTLEFT="ShiftLeft",K_SHIFTRIGHT="ShiftRight",K_CONTROLLEFT="ControlLeft",K_CONTROLRIGHT="ControlRight",K_ALTLEFT="AltLeft",K_ALTRIGHT="AltRight",K_PAUSE="Pause",K_CAPSLOCK="CapsLock",K_ESCAPE="Escape",K_SPACE="Space",K_PAGEUP="PageUp",K_PAGEDOWN="PageDown",K_END="End",K_HOME="Home",K_ARROWUP="ArrowUp",K_ARROWDOWN="ArrowDown",K_ARROWLEFT="ArrowLeft",K_ARROWRIGHT="ArrowRight",K_PRINTSCREEN="PrintScreen",K_INSERT="Insert",K_DELETE="Delete",K_0="Digit0",K_1="Digit1",K_2="Digit2",K_3="Digit3",K_4="Digit4",K_5="Digit5",K_6="Digit6",K_7="Digit7",K_8="Digit8",K_9="Digit9",K_A="KeyA",K_B="KeyB",K_C="KeyC",K_D="KeyD",K_E="KeyE",K_F="KeyF",K_G="KeyG",K_H="KeyH",K_I="KeyI",K_J="KeyJ",K_K="KeyK",K_L="KeyL",K_M="KeyM",K_N="KeyN",K_O="KeyO",K_P="KeyP",K_Q="KeyQ",K_R="KeyR",K_S="KeyS",K_T="KeyT",K_U="KeyU",K_V="KeyV",K_W="KeyW",K_X="KeyX",K_Y="KeyY",K_Z="KeyZ",K_LEFTWINDOW="MetaLeft",K_RIGHTWINDOW="MetaRight",K_CONTEXTMENU="ContextMenu",K_NUM0="Numpad0",K_NUM1="Numpad1",K_NUM2="Numpad2",K_NUM3="Numpad3",K_NUM4="Numpad4",K_NUM5="Numpad5",K_NUM6="Numpad6",K_NUM7="Numpad7",K_NUM8="Numpad8",K_NUM9="Numpad9",K_MULTIPLY="NumpadMultiply",K_ADD="NumpadAdd",K_SUBTRACT="NumpadSubtract",K_DECIMAL="NumpadDecimal",K_DIVIDE="NumpadDivide",K_F1="F1",K_F2="F2",K_F3="F3",K_F4="F4",K_F5="F5",K_F6="F6",K_F7="F7",K_F8="F8",K_F9="F9",K_F10="F10",K_F11="F11",K_F12="F12",K_NUMLOCK="NumLock",K_SCROLLLOCK="ScrollLock",K_SEMICOLON="Semicolon",K_EQUAL="Equal",K_COMMA="Comma",K_MINUS="Minus",K_PERIOD="Period",K_SLASH="Slash",K_BACKQUOTE="Backquote",K_BRACKETLEFT="BracketLeft",K_BACKSLASH="Backslash",K_BRACKETRIGHT="BracketRight",K_QUOTE="Quote",C_BLACK="#000000",C_WHITE="#ffffff",C_SILVER="#c0c0c0",C_GRAY="#808080",C_MAROON="#800000",C_RED="#ff0000",C_PURPLE="#800080",C_FUCHSIA="#ff00ff",C_GREEN="#008000",C_LIME="#00ff00",C_OLIVE="#808000",C_YELLOW="#ffff00",C_NAVY="#000080",C_BLUE="#0000ff",C_TEAL="#008080",C_AQUA="#00ffff",LoadedSounds=[],On={KeyDown:function(key,func,shouldPreventDefault){let canExe=!0;document.body.addEventListener("keydown",(function(event){event.code==key&&canExe&&(shouldPreventDefault&&event.preventDefault(),func(),canExe=!1)}),!1),document.body.addEventListener("keyup",(function(event){event.code==key&&(canExe=!0)}),!1)},KeyUp:function(key,func,shouldPreventDefault){let canExe=!0;document.body.addEventListener("keydown",(function(event){event.code==key&&(canExe=!0)}),!1),document.body.addEventListener("keyup",(function(event){event.code==key&&canExe&&(shouldPreventDefault&&event.preventDefault(),func(),canExe=!1)}),!1)},MouseDown:void 0,MouseUp:void 0},KeysPressed={};let IsMouseDown=!1;const Canvas=class{constructor(parentElement,width,height){const thisCanvas=document.createElement("canvas");thisCanvas.setAttribute("width",width+"px"),thisCanvas.setAttribute("height",height+"px"),parentElement.appendChild(thisCanvas);const thisClass=this,ctx=thisCanvas.getContext("2d"),objects=[];let background;this.HTML=thisCanvas,this.ctx=ctx,this.width=width,this.height=height,this.centerX=width/2,this.centerY=height/2,this.objects=objects,this.Mouse={x:0,y:0},this.On={KeyDown:function(key,func,shouldPreventDefault){let canExe=!0;thisCanvas.addEventListener("keydown",(function(event){event.code==key&&canExe&&(shouldPreventDefault&&event.preventDefault(),func(),canExe=!1)}),!1),document.body.addEventListener("keyup",(function(event){event.code==key&&(canExe=!0)}),!1)},KeyUp:function(key,func,shouldPreventDefault){let canExe=!0;document.body.addEventListener("keydown",(function(event){event.code==key&&(canExe=!0)}),!1),thisCanvas.addEventListener("keyup",(function(event){event.code==key&&canExe&&(shouldPreventDefault&&event.preventDefault(),func(),canExe=!1)}),!1)},MouseDown:void 0,MouseUp:void 0},this.Fill=function(color){return background={type:"background",x:0,y:0,width:thisCanvas.width,height:thisCanvas.height,color:color},color},this.Draw=function(){for(let i=0;i<arguments.length;i++)objects.push(arguments[i])},this.Erase=function(){for(let i=0;i<arguments.length;i++)objects.splice(objects.indexOf(arguments[i]),1)},this.Clear=function(){ctx.clearRect(0,0,thisCanvas.width,thisCanvas.height),background=void 0,objects=[]},function update(){!function draw(){ctx.clearRect(0,0,thisCanvas.width,thisCanvas.height),null!=background&&(ctx.fillStyle=background.color,ctx.fillRect(background.x,background.y,background.width,background.height));for(let i=0;i<objects.length;i++)if("img"==objects[i].type){const radians=objects[i].rotation*Math.PI/180;ctx.globalAlpha=objects[i].opacity/100,ctx.save(),ctx.translate(objects[i].x,objects[i].y),ctx.rotate(radians),ctx.drawImage(objects[i].img,-objects[i].width/2,-objects[i].height/2,objects[i].width,objects[i].height),objects[i].showBorder&&(ctx.lineWidth=objects[i].borderWidth,ctx.strokeStyle=objects[i].borderColor,ctx.strokeRect(-objects[i].width/2+objects[i].borderWidth/2,-objects[i].height/2+objects[i].borderWidth/2,objects[i].width-objects[i].borderWidth,objects[i].height-objects[i].borderWidth)),ctx.restore()}else if("line"==objects[i].type)ctx.lineWidth=objects[i].lineWidth,ctx.strokeStyle=objects[i].color,ctx.globalAlpha=objects[i].opacity/100,ctx.beginPath(),ctx.moveTo(objects[i].point1.x,objects[i].point1.y),ctx.lineTo(objects[i].point2.x,objects[i].point2.y),ctx.stroke();else if("polygon"==objects[i].type){const points=objects[i].points,radians=objects[i].rotation*Math.PI/180;if(ctx.save(),ctx.translate(objects[i].x,objects[i].y),ctx.rotate(radians),ctx.beginPath(),objects[i].stroke){const lineWidth=objects[i].lineWidth;let j=points.length-1,fixedX=1-Math.abs(lineWidth/points[j].offsetX)/2,fixedY=1-Math.abs(lineWidth/points[j].offsetY)/2;for(ctx.moveTo(points[j].offsetX*fixedX,points[j].offsetY*fixedY),j=0;j<points.length;j++)fixedX=1-Math.abs(lineWidth/points[j].offsetX)/2,fixedY=1-Math.abs(lineWidth/points[j].offsetY)/2,ctx.lineTo(points[j].offsetX*fixedX,points[j].offsetY*fixedY);ctx.globalAlpha=objects[i].opacity/100,ctx.lineWidth=lineWidth,ctx.strokeStyle=objects[i].color,ctx.stroke()}else{ctx.moveTo(points[points.length-1].offsetX,points[points.length-1].offsetY);for(let i=0;i<points.length;i++)ctx.lineTo(points[i].offsetX,points[i].offsetY);ctx.globalAlpha=objects[i].opacity/100,ctx.fillStyle=objects[i].color,ctx.fill()}if(objects[i].showBorder){const borderWidth=objects[i].borderWidth;let j=points.length-1,fixedX=1-Math.abs(borderWidth/points[j].offsetX)/2,fixedY=1-Math.abs(borderWidth/points[j].offsetY)/2;for(ctx.moveTo(points[j].offsetX*fixedX,points[j].offsetY*fixedY),j=0;j<points.length;j++)fixedX=1-Math.abs(borderWidth/points[j].offsetX)/2,fixedY=1-Math.abs(borderWidth/points[j].offsetY)/2,ctx.lineTo(points[j].offsetX*fixedX,points[j].offsetY*fixedY);ctx.globalAlpha=objects[i].opacity/100,ctx.lineWidth=borderWidth,ctx.strokeStyle=objects[i].borderColor,ctx.stroke()}ctx.restore()}else if("rect"==objects[i].type){const radians=objects[i].rotation*Math.PI/180;ctx.globalAlpha=objects[i].opacity/100,ctx.save(),ctx.translate(objects[i].x,objects[i].y),ctx.rotate(radians),objects[i].stroke?(ctx.lineWidth=objects[i].lineWidth,ctx.strokeStyle=objects[i].color,ctx.strokeRect(-objects[i].width/2+objects[i].lineWidth/2,-objects[i].height/2+objects[i].lineWidth/2,objects[i].width-objects[i].lineWidth,objects[i].height-objects[i].lineWidth)):(ctx.fillStyle=objects[i].color,ctx.fillRect(-objects[i].width/2,-objects[i].height/2,objects[i].width,objects[i].height)),objects[i].showBorder&&(ctx.lineWidth=objects[i].borderWidth,ctx.strokeStyle=objects[i].borderColor,ctx.strokeRect(-objects[i].width/2+objects[i].borderWidth/2,-objects[i].height/2+objects[i].borderWidth/2,objects[i].width-objects[i].borderWidth,objects[i].height-objects[i].borderWidth)),ctx.restore()}else if("circle"==objects[i].type)ctx.globalAlpha=objects[i].opacity/100,ctx.beginPath(),objects[i].stroke?(ctx.lineWidth=objects[i].lineWidth,ctx.strokeStyle=objects[i].color,ctx.arc(objects[i].x,objects[i].y,objects[i].radius-objects[i].lineWidth/2,0,2*Math.PI),ctx.stroke()):(ctx.fillStyle=objects[i].color,ctx.arc(objects[i].x,objects[i].y,objects[i].radius,0,2*Math.PI),ctx.fill()),objects[i].showBorder&&(ctx.lineWidth=objects[i].borderWidth,ctx.strokeStyle=objects[i].borderColor,ctx.beginPath(),ctx.arc(objects[i].x,objects[i].y,objects[i].radius-objects[i].borderWidth/2+.5,0,2*Math.PI),ctx.stroke());else if("text"==objects[i].type){const radians=objects[i].rotation*Math.PI/180;ctx.globalAlpha=objects[i].opacity/100,ctx.save(),ctx.translate(objects[i].x,objects[i].y),ctx.rotate(radians),ctx.textAlign="center",ctx.textBaseline="middle",ctx.font=objects[i].fontSize+" "+objects[i].font,ctx.fillStyle=objects[i].color,ctx.fillText(objects[i].text,0,0),ctx.restore()}}(),thisCanvas.width!=thisClass.width&&thisCanvas.setAttribute("width",thisClass.width+"px"),thisCanvas.height!=thisClass.height&&thisCanvas.setAttribute("height",thisClass.height+"px"),thisClass.centerX!=thisCanvas.width/2&&(thisClass.centerX=thisCanvas.width/2),thisClass.centerY!=thisCanvas.height/2&&(thisClass.centerY=thisCanvas.height/2),JSON.stringify(thisClass.objects)!=JSON.stringify(objects)&&(thisClass.objects=objects),requestAnimationFrame(update)}(),thisCanvas.addEventListener("mousemove",(function(event){const rect=thisCanvas.getBoundingClientRect(),scaleX=thisCanvas.width/rect.width,scaleY=thisCanvas.height/rect.height;thisClass.Mouse.x=(event.clientX-rect.left)*scaleX,thisClass.Mouse.y=(event.clientY-rect.top)*scaleY}),!1),thisCanvas.addEventListener("mousedown",(function(){"function"==typeof thisClass.On.MouseDown&&thisClass.On.MouseDown();const mouseX=thisClass.Mouse.x,mouseY=thisClass.Mouse.y;function getRotatedPos(origin,point,angle){return{x:Math.cos(angle)*(point.x-origin.x)+Math.sin(angle)*(point.y-origin.y)+origin.x,y:Math.cos(angle)*(point.y-origin.y)-Math.sin(angle)*(point.x-origin.x)+origin.y}}for(let i=0;i<objects.length;i++)if("function"==typeof objects[i].On.MouseDown)if("rect"==objects[i].type||"img"==objects[i].type){const origin={x:objects[i].x,y:objects[i].y},radians=objects[i].rotation*Math.PI/180,rectX=objects[i].x-objects[i].width/2,rectY=objects[i].y-objects[i].height/2,newPoint=getRotatedPos(origin,{x:mouseX,y:mouseY},radians);newPoint.x>rectX&&newPoint.x<rectX+objects[i].width&&newPoint.y>rectY&&newPoint.y<rectY+objects[i].height&&objects[i].On.MouseDown()}else if("polygon"==objects[i].type){const points=objects[i].points,radians=objects[i].rotation*Math.PI/180,mouse=getRotatedPos({x:objects[i].x,y:objects[i].y},{x:mouseX,y:mouseY},radians);let collision=!1,next=0;for(let current=0;current<points.length;current++){next=current+1,next==points.length&&(next=0);const currentPoint=points[current],nextPoint=points[next];(currentPoint.y>=mouse.y&&nextPoint.y<mouse.y||currentPoint.y<mouse.y&&nextPoint.y>=mouse.y)&&mouse.x<(nextPoint.x-currentPoint.x)*(mouse.y-currentPoint.y)/(nextPoint.y-currentPoint.y)+currentPoint.x&&(collision=!collision)}collision&&objects[i].On.MouseDown()}else if("circle"==objects[i].type){const distX=Math.abs(mouseX-objects[i].x),distY=Math.abs(mouseY-objects[i].y);Math.sqrt(distX**2+distY**2)<objects[i].radius&&objects[i].On.MouseDown()}else if("line"==objects[i].type){function getAngle(centerX,centerY,endX,endY){const distX=endX-centerX,distY=endY-centerY;return Math.atan2(distY,distX)}let point1=objects[i].point1,point2=objects[i].point2;const midX=(point1.x+point2.x)/2,midY=(point1.y+point2.y)/2,radians=getAngle(midX,midY,point2.x,point2.y),lineWidth=objects[i].lineWidth,mouse=getRotatedPos({x:midX,y:midY},{x:mouseX,y:mouseY},radians);point1=getRotatedPos({x:midX,y:midY},point1,radians),point2=getRotatedPos({x:midX,y:midY},point2,radians);const rect={x:point1.x,y:point1.y-lineWidth/2,width:Math.abs(point1.x-point2.x),height:lineWidth};mouse.x>rect.x&&mouse.x<rect.x+rect.width&&mouse.y>rect.y&&mouse.y<rect.y+rect.height&&objects[i].On.MouseDown()}}),!1),thisCanvas.addEventListener("mouseup",(function(){"function"==typeof thisClass.On.MouseUp&&thisClass.On.MouseUp();const mouseX=thisClass.Mouse.x,mouseY=thisClass.Mouse.y;function getRotatedPos(origin,point,angle){return{x:Math.cos(angle)*(point.x-origin.x)+Math.sin(angle)*(point.y-origin.y)+origin.x,y:Math.cos(angle)*(point.y-origin.y)-Math.sin(angle)*(point.x-origin.x)+origin.y}}for(let i=0;i<objects.length;i++)if("function"==typeof objects[i].On.MouseUp)if("rect"==objects[i].type||"img"==objects[i].type){const origin={x:objects[i].x,y:objects[i].y},radians=objects[i].rotation*Math.PI/180,rectX=objects[i].x-objects[i].width/2,rectY=objects[i].y-objects[i].height/2,newPoint=getRotatedPos(origin,{x:mouseX,y:mouseY},radians);newPoint.x>rectX&&newPoint.x<rectX+objects[i].width&&newPoint.y>rectY&&newPoint.y<rectY+objects[i].height&&objects[i].On.MouseUp()}else if("polygon"==objects[i].type){const points=objects[i].points,radians=objects[i].rotation*Math.PI/180,mouse=getRotatedPos({x:objects[i].x,y:objects[i].y},{x:mouseX,y:mouseY},radians);let collision=!1,next=0;for(let current=0;current<points.length;current++){next=current+1,next==points.length&&(next=0);const currentPoint=points[current],nextPoint=points[next];(currentPoint.y>=mouse.y&&nextPoint.y<mouse.y||currentPoint.y<mouse.y&&nextPoint.y>=mouse.y)&&mouse.x<(nextPoint.x-currentPoint.x)*(mouse.y-currentPoint.y)/(nextPoint.y-currentPoint.y)+currentPoint.x&&(collision=!collision)}collision&&objects[i].On.MouseUp()}else if("circle"==objects[i].type){const distX=Math.abs(mouseX-objects[i].x),distY=Math.abs(mouseY-objects[i].y);Math.sqrt(distX**2+distY**2)<objects[i].radius&&objects[i].On.MouseUp()}else if("line"==objects[i].type){function getAngle(centerX,centerY,endX,endY){const distX=endX-centerX,distY=endY-centerY;return Math.atan2(distY,distX)}let point1=objects[i].point1,point2=objects[i].point2;const midX=(point1.x+point2.x)/2,midY=(point1.y+point2.y)/2,radians=getAngle(midX,midY,point2.x,point2.y),lineWidth=objects[i].lineWidth,mouse=getRotatedPos({x:midX,y:midY},{x:mouseX,y:mouseY},radians);point1=getRotatedPos({x:midX,y:midY},point1,radians),point2=getRotatedPos({x:midX,y:midY},point2,radians);const rect={x:point1.x,y:point1.y-lineWidth/2,width:Math.abs(point1.x-point2.x),height:lineWidth};mouse.x>rect.x&&mouse.x<rect.x+rect.width&&mouse.y>rect.y&&mouse.y<rect.y+rect.height&&objects[i].On.MouseUp()}}),!1)}},LoadImg=function(){for(let i=0;i<arguments.length;i++){const img=new Image;img.onload=function(){img.src=this.src},img.src=arguments[i]}return arguments},LoadSound=function(){for(let i=0;i<arguments.length;i++){const sound=new Audio;sound.onload=function(){sound.src=this.src},sound.src=arguments[i],LoadedSounds.push({audio:sound,src:arguments[i]})}return arguments},Img=function(src,x,y,width,height){const object={type:"img",img:new Image,x:x,y:y,width:width,height:height,opacity:100,velocityX:0,velocityY:0,gravityXStrength:0,gravityYStrength:0,gravityXEnabled:!1,gravityYEnabled:!1,rotation:0,showBorder:!1,borderWidth:2,borderColor:"#000000",hitbox:{topLeft:{x:x-width/2,y:y-height/2},topRight:{x:x+width/2,y:y-height/2},bottomLeft:{x:x-width/2,y:y+height/2},bottomRight:{x:x+width/2,y:y+height/2}},On:{MouseDown:void 0,MouseUp:void 0},SetPosition:function(x,y){return object.x=x,object.y=y,{x:x,y:y}},GlideTo:function(x,y,timeInMs){const xDist=object.x-x,yDist=object.y-y;let n=0,time0=0;n=xDist>0?xDist:-xDist;for(let i=0;i<n;i++)setTimeout((function(){xDist>0?object.x--:object.x++}),time0),time0+=xDist>0?timeInMs/xDist:timeInMs/-xDist;time0=0,n=yDist>0?yDist:-yDist;for(let i=0;i<n;i++)setTimeout((function(){yDist>0?object.y--:object.y++}),time0),time0+=yDist>0?timeInMs/yDist:timeInMs/-yDist;return{x:x,y:y}},SetBorder:function(width,color){return object.showBorder=!0,object.borderWidth=width,object.borderColor=color,width+"px "+color},PointTowards:function(x,y){return object.rotation=function getAngle(x1,y1,x2,y2){const distX=x2-x1,distY=y2-y1;return 180*Math.atan2(distY,distX)/Math.PI}(x,y,object.x,object.y)-90,object.rotation}};function getRotatedPos(origin,point,angle){const cos=Math.cos(angle),sin=Math.sin(angle);return{x:cos*(point.x-origin.x)+sin*(point.y-origin.y)+origin.x,y:cos*(point.y-origin.y)-sin*(point.x-origin.x)+origin.y}}return object.img.src=src,function update(){object.gravityXEnabled&&(object.velocityX+=object.gravityXStrength),object.gravityYEnabled&&(object.velocityY+=object.gravityYStrength),object.x+=object.velocityX,object.y+=object.velocityY;const radians=-object.rotation*Math.PI/180;object.hitbox.topLeft=getRotatedPos({x:object.x,y:object.y},{x:object.x-object.width/2,y:object.y-object.height/2},radians),object.hitbox.topRight=getRotatedPos({x:object.x,y:object.y},{x:object.x+object.width/2,y:object.y-object.height/2},radians),object.hitbox.bottomLeft=getRotatedPos({x:object.x,y:object.y},{x:object.x-object.width/2,y:object.y+object.height/2},radians),object.hitbox.bottomRight=getRotatedPos({x:object.x,y:object.y},{x:object.x+object.width/2,y:object.y+object.height/2},radians),requestAnimationFrame(update)}(),object},Line=function(point1,point2,color){const object={type:"line",point1:{x:point1[0],y:point1[1],velocityX:0,velocityY:0,gravityXStrength:0,gravityYStrength:0,gravityXEnabled:!1,gravityYEnabled:!1,SetPosition:function(x,y){return object.point1.x=x,object.point1.y=y,{x:x,y:y}},GlideTo:function(x,y,timeInMs){const xDist=object.x-x,yDist=object.y-y;let n=0,time0=0;n=xDist>0?xDist:-xDist;for(let i=0;i<n;i++)setTimeout((function(){xDist>0?object.x--:object.x++}),time0),time0+=xDist>0?timeInMs/xDist:timeInMs/-xDist;time0=0,n=yDist>0?yDist:-yDist;for(let i=0;i<n;i++)setTimeout((function(){yDist>0?object.y--:object.y++}),time0),time0+=yDist>0?timeInMs/yDist:timeInMs/-yDist;return{x:x,y:y}}},point2:{x:point2[0],y:point2[1],velocityX:0,velocityY:0,gravityXStrength:0,gravityYStrength:0,gravityXEnabled:!1,gravityYEnabled:!1,SetPosition:function(x,y){return object.point2.x=x,object.point2.y=y,{x:x,y:y}},GlideTo:function(x,y,timeInMs){const xDist=object.x-x,yDist=object.y-y;let n=0,time0=0;n=xDist>0?xDist:-xDist;for(let i=0;i<n;i++)setTimeout((function(){xDist>0?object.x--:object.x++}),time0),time0+=xDist>0?timeInMs/xDist:timeInMs/-xDist;time0=0,n=yDist>0?yDist:-yDist;for(let i=0;i<n;i++)setTimeout((function(){yDist>0?object.y--:object.y++}),time0),time0+=yDist>0?timeInMs/yDist:timeInMs/-yDist;return{x:x,y:y}}},midPoint:{x:(point1[0]+point2[0])/2,y:(point1[1]+point2[1])/2},color:color,lineWidth:1,length:getDistance(point1[0],point1[1],point2[0],point2[1]),angle:void 0,opacity:100,On:{MouseDown:void 0,MouseUp:void 0}};function getDistance(x1,y1,x2,y2){const distX=Math.abs(x1-x2),distY=Math.abs(y1-y2);return Math.sqrt(distX**2+distY**2)}function getAngle(centerX,centerY,endX,endY){const distX=endX-centerX,distY=endY-centerY;return Math.atan2(distY,distX)}return object.angle=getAngle(object.midPoint.x,object.midPoint.y,point2[0],point2[0])/Math.PI*180,function update(){object.point1.gravityXEnabled&&(object.point1.velocityX+=object.point1.gravityXStrength),object.point1.gravityYEnabled&&(object.point1.velocityY+=object.point1.gravityYStrength),object.point1.x+=object.point1.velocityX,object.point1.y+=object.point1.velocityY,object.point2.gravityXEnabled&&(object.point2.velocityX+=object.point2.gravityXStrength),object.point2.gravityYEnabled&&(object.point2.velocityY+=object.point2.gravityYStrength),object.point2.x+=object.point2.velocityX,object.point2.y+=object.point2.velocityY,object.length=getDistance(object.point1.x,object.point1.y,object.point2.x,object.point2.y),object.midPoint={x:(object.point1.x+object.point2.x)/2,y:(object.point1.y+object.point2.y)/2},object.angle=getAngle(object.midPoint.x,object.midPoint.y,object.point2.x,object.point2.y)/Math.PI*180,requestAnimationFrame(update)}(),object},Polygon=function(){const object={type:"polygon",x:void 0,y:void 0,points:[],sides:[],color:arguments[arguments.length-1],opacity:100,velocityX:0,velocityY:0,gravityXStrength:0,gravityYStrength:0,gravityXEnabled:!1,gravityYEnabled:!1,lineWidth:1,stroke:!1,rotation:0,showBorder:!1,borderWidth:2,borderColor:"#000000",On:{MouseDown:void 0,MouseUp:void 0},SetPosition:function(x,y){return object.x=x,object.y=y,{x:x,y:y}},GlideTo:function(x,y,timeInMs){const xDist=object.x-x,yDist=object.y-y;let n=0,time0=0;n=xDist>0?xDist:-xDist;for(let i=0;i<n;i++)setTimeout((function(){xDist>0?object.x--:object.x++}),time0),time0+=xDist>0?timeInMs/xDist:timeInMs/-xDist;time0=0,n=yDist>0?yDist:-yDist;for(let i=0;i<n;i++)setTimeout((function(){yDist>0?object.y--:object.y++}),time0),time0+=yDist>0?timeInMs/yDist:timeInMs/-yDist;return{x:x,y:y}},SetBorder:function(width,color){return object.showBorder=!0,object.borderWidth=width,object.borderColor=color,width+"px "+color},PointTowards:function(x,y){return object.rotation=function getAngle(x1,y1,x2,y2){const distX=x2-x1,distY=y2-y1;return 180*Math.atan2(distY,distX)/Math.PI}(x,y,object.x,object.y)-90,object.rotation}};for(let i=0;i<arguments.length-1;i++){const point={x:arguments[i][0],y:arguments[i][1],offsetX:void 0,offsetY:void 0,SetX:function(x){return point.offsetX=x-object.x,x},SetY:function(y){return point.offsetY=y-object.y,y},SetPosition:function(x,y){return point.offsetX=x-object.x,point.offsetY=y-object.y,{x:x,y:y}},GlideTo:function(x,y,timeInMs){const xDist=point.x-x,yDist=point.y-y;let n=0,time0=0;n=xDist>0?xDist:-xDist;for(let i=0;i<n;i++)setTimeout((function(){xDist>0?point.offsetX--:point.offsetX++}),time0),time0+=xDist>0?timeInMs/xDist:timeInMs/-xDist;time0=0,n=yDist>0?yDist:-yDist;for(let i=0;i<n;i++)setTimeout((function(){yDist>0?point.offsetY--:point.offsetY++}),time0),time0+=yDist>0?timeInMs/yDist:timeInMs/-yDist;return{x:x,y:y}},SetOffsetX:function(offsetX){return point.offsetX=offsetX,offsetX},SetOffsetY:function(offsetY){return point.offsetY=offsetY,offsetY},SetOffset:function(offsetX,offsetY){return point.offsetX=offsetX,point.offsetY=offsetY,{offsetX:offsetX,offsetY:offsetY}}};object.points.push(point)}return function setup(){const points=object.points;let totalX=0,totalY=0;for(let i=0;i<points.length;i++)totalX+=points[i].x,totalY+=points[i].y;object.x=totalX/points.length,object.y=totalY/points.length;for(let i=0;i<points.length;i++)points[i].offsetX=points[i].x-object.x,points[i].offsetY=points[i].y-object.y}(),function update(){const points=object.points,sides=[];for(let i=0;i<points.length;i++){let side;points[i].x=object.x+points[i].offsetX,points[i].y=object.y+points[i].offsetY,side=i+1<points.length?{point1:points[i],point2:points[i+1]}:{point1:points[i],point2:points[0]},sides.push(side)}JSON.stringify(object.sides)!=JSON.stringify(sides)&&(object.sides=sides),object.gravityXEnabled&&(object.velocityX+=object.gravityXStrength),object.gravityYEnabled&&(object.velocityY+=object.gravityYStrength),object.x+=object.velocityX,object.y+=object.velocityY,requestAnimationFrame(update)}(),object},Rect=function(x,y,width,height,color){const object={type:"rect",x:x,y:y,width:width,height:height,color:color,velocityX:0,velocityY:0,gravityXStrength:0,gravityYStrength:0,gravityXEnabled:!1,gravityYEnabled:!1,lineWidth:1,stroke:!1,rotation:0,opacity:100,showBorder:!1,borderWidth:2,borderColor:"#000000",hitbox:{topLeft:{x:x-width/2,y:y-height/2},topRight:{x:x+width/2,y:y-height/2},bottomLeft:{x:x-width/2,y:y+height/2},bottomRight:{x:x+width/2,y:y+height/2}},On:{MouseDown:void 0,MouseUp:void 0},SetPosition:function(x,y){return object.x=x,object.y=y,{x:x,y:y}},GlideTo:function(x,y,timeInMs){const xDist=object.x-x,yDist=object.y-y;let n=0,time0=0;n=xDist>0?xDist:-xDist;for(let i=0;i<n;i++)setTimeout((function(){xDist>0?object.x--:object.x++}),time0),time0+=xDist>0?timeInMs/xDist:timeInMs/-xDist;time0=0,n=yDist>0?yDist:-yDist;for(let i=0;i<n;i++)setTimeout((function(){yDist>0?object.y--:object.y++}),time0),time0+=yDist>0?timeInMs/yDist:timeInMs/-yDist;return{x:x,y:y}},SetBorder:function(width,color){return object.showBorder=!0,object.borderWidth=width,object.borderColor=color,width+"px "+color},PointTowards:function(x,y){return object.rotation=function getAngle(x1,y1,x2,y2){const distX=x2-x1,distY=y2-y1;return 180*Math.atan2(distY,distX)/Math.PI}(x,y,object.x,object.y)-90,object.rotation}};function getRotatedPos(origin,point,angle){return{x:Math.cos(angle)*(point.x-origin.x)+Math.sin(angle)*(point.y-origin.y)+origin.x,y:Math.cos(angle)*(point.y-origin.y)-Math.sin(angle)*(point.x-origin.x)+origin.y}}return function update(){object.gravityXEnabled&&(object.velocityX+=object.gravityXStrength),object.gravityYEnabled&&(object.velocityY+=object.gravityYStrength),object.x+=object.velocityX,object.y+=object.velocityY;const radians=-object.rotation*Math.PI/180;object.hitbox.topLeft=getRotatedPos({x:object.x,y:object.y},{x:object.x-object.width/2,y:object.y-object.height/2},radians),object.hitbox.topRight=getRotatedPos({x:object.x,y:object.y},{x:object.x+object.width/2,y:object.y-object.height/2},radians),object.hitbox.bottomLeft=getRotatedPos({x:object.x,y:object.y},{x:object.x-object.width/2,y:object.y+object.height/2},radians),object.hitbox.bottomRight=getRotatedPos({x:object.x,y:object.y},{x:object.x+object.width/2,y:object.y+object.height/2},radians),requestAnimationFrame(update)}(),object},Circle=function(x,y,radius,color){const object={type:"circle",x:x,y:y,radius:radius,color:color,velocityX:0,velocityY:0,gravityXStrength:0,gravityYStrength:0,gravityXEnabled:!1,gravityYEnabled:!1,lineWidth:1,stroke:!1,opacity:100,showBorder:!1,borderWidth:2,borderColor:"#000000",On:{MouseDown:void 0,MouseUp:void 0},SetPosition:function(x,y){return object.x=x,object.y=y,{x:x,y:y}},GlideTo:function(x,y,timeInMs){const xDist=object.x-x,yDist=object.y-y;let n=0,time0=0;n=xDist>0?xDist:-xDist;for(let i=0;i<n;i++)setTimeout((function(){xDist>0?object.x--:object.x++}),time0),time0+=xDist>0?timeInMs/xDist:timeInMs/-xDist;time0=0,n=yDist>0?yDist:-yDist;for(let i=0;i<n;i++)setTimeout((function(){yDist>0?object.y--:object.y++}),time0),time0+=yDist>0?timeInMs/yDist:timeInMs/-yDist;return{x:x,y:y}},SetBorder:function(width,color){return object.showBorder=!0,object.borderWidth=width,object.borderColor=color,width+"px "+color}};return function update(){object.gravityXEnabled&&(object.velocityX+=object.gravityXStrength),object.gravityYEnabled&&(object.velocityY+=object.gravityYStrength),object.x+=object.velocityX,object.y+=object.velocityY,requestAnimationFrame(update)}(),object},Text=function(text,fontSize,font,x,y,color){const object={type:"text",text:text,font:font,fontSize:fontSize,x:x,y:y,color:color,opacity:100,velocityX:0,velocityY:0,gravityXStrength:0,gravityYStrength:0,gravityXEnabled:!1,gravityYEnabled:!1,rotation:0,SetPosition:function(x,y){return object.x=x,object.y=y,{x:x,y:y}},GlideTo:function(x,y,timeInMs){const xDist=object.x-x,yDist=object.y-y;let n=0,time0=0;n=xDist>0?xDist:-xDist;for(let i=0;i<n;i++)setTimeout((function(){xDist>0?object.x--:object.x++}),time0),time0+=xDist>0?timeInMs/xDist:timeInMs/-xDist;time0=0,n=yDist>0?yDist:-yDist;for(let i=0;i<n;i++)setTimeout((function(){yDist>0?object.y--:object.y++}),time0),time0+=yDist>0?timeInMs/yDist:timeInMs/-yDist;return{x:x,y:y}},PointTowards:function(x,y){return object.rotation=function getAngle(x1,y1,x2,y2){const distX=x2-x1,distY=y2-y1;return 180*Math.atan2(distY,distX)/Math.PI}(x,y,object.x,object.y)-90,object.rotation}};return function update(){object.gravityXEnabled&&(object.velocityX+=object.gravityXStrength),object.gravityYEnabled&&(object.velocityY+=object.gravityYStrength),object.x+=object.velocityX,object.y+=object.velocityY,requestAnimationFrame(update)}(),object},PlaySound=function(src){let sound;for(let i=0;i<LoadedSounds.length;i++)LoadedSounds[i].audio.pause(),LoadedSounds[i].src==src&&(sound=LoadedSounds[i]);sound.audio.play()},IsColliding=function(object1,object2){function getRotatedPos(origin,point,angle){return{x:Math.cos(angle)*(point.x-origin.x)+Math.sin(angle)*(point.y-origin.y)+origin.x,y:Math.cos(angle)*(point.y-origin.y)-Math.sin(angle)*(point.x-origin.x)+origin.y}}function getAngle(centerX,centerY,endX,endY){const distX=endX-centerX,distY=endY-centerY;return Math.atan2(distY,distX)}function checkLines(line1,line2){const line=((line2.point2.x-line2.point1.x)*(line1.point1.y-line2.point1.y)-(line2.point2.y-line2.point1.y)*(line1.point1.x-line2.point1.x))/((line2.point2.y-line2.point1.y)*(line1.point2.x-line1.point1.x)-(line2.point2.x-line2.point1.x)*(line1.point2.y-line1.point1.y)),line0=((line1.point2.x-line1.point1.x)*(line1.point1.y-line2.point1.y)-(line1.point2.y-line1.point1.y)*(line1.point1.x-line2.point1.x))/((line2.point2.y-line2.point1.y)*(line1.point2.x-line1.point1.x)-(line2.point2.x-line2.point1.x)*(line1.point2.y-line1.point1.y));return line>=0&&line<=1&&line0>=0&&line0<=1}function getRectFromLine(point1,point2,midX,midY,lineWidth,radians){const origin={x:midX,y:midY},newPoint1=getRotatedPos(origin,point1,radians),newPoint2=getRotatedPos(origin,point2,radians),width=Math.abs(newPoint1.x-newPoint2.x),height=lineWidth,topLeft=getRotatedPos(origin,{x:newPoint1.x,y:newPoint1.y-height/2},-radians),topRight=getRotatedPos(origin,{x:newPoint2.x,y:newPoint2.y-height/2},-radians),bottomLeft=getRotatedPos(origin,{x:newPoint1.x,y:newPoint1.y+height/2},-radians),bottomRight=getRotatedPos(origin,{x:newPoint2.x,y:newPoint2.y+height/2},-radians);return{x:newPoint1.x,y:newPoint1.y-height/2,width:width,height:height,points:[topLeft,topRight,bottomLeft,bottomRight],sides:[{point1:topLeft,point2:topRight},{point1:bottomLeft,point2:bottomRight},{point1:topLeft,point2:bottomLeft},{point1:topRight,point2:bottomRight}]}}function checkPolygonPoint(points,point){let collision=!1,next=0;for(let current=0;current<points.length;current++){next=current+1,next==points.length&&(next=0);const currentPoint=points[current],nextPoint=points[next];(currentPoint.y>=point.y&&nextPoint.y<point.y||currentPoint.y<point.y&&nextPoint.y>=point.y)&&point.x<(nextPoint.x-currentPoint.x)*(point.y-currentPoint.y)/(nextPoint.y-currentPoint.y)+currentPoint.x&&(collision=!collision)}return collision}function checkLineCircle(point1,point2,circle){const x=circle.x,y=circle.y,radius=circle.radius,distX=point2.x-point1.x,distY=point2.y-point1.y,u=Math.min(1,Math.max(0,((x-point1.x)*distX+(y-point1.y)*distY)/(distY*distY+distX*distX))),closestX=point1.x+distX*u-x,closestY=point1.y+distY*u-y;return closestX*closestX+closestY*closestY<radius*radius}if("circle"==object1.type&&"line"==object2.type){const point1=object2.point1,point2=object2.point2,midX=(point1.x+point2.x)/2,midY=(point1.y+point2.y)/2,lineWidth=object2.lineWidth;let radians=getAngle(midX,midY,point2.x,point2.y);const rect=getRectFromLine(point1,point2,midX,midY,lineWidth,radians),newPoint=getRotatedPos({x:midX,y:midY},{x:object1.x,y:object1.y},radians);let closestX,closestY;closestX=newPoint.x<rect.x?rect.x:newPoint.x>rect.x+rect.width?rect.x+rect.width:newPoint.x,closestY=newPoint.y<rect.y?rect.y:newPoint.y>rect.y+rect.height?rect.y+rect.height:newPoint.y;const distX=Math.abs(newPoint.x-closestX),distY=Math.abs(newPoint.y-closestY);return Math.sqrt(distX**2+distY**2)<object1.radius}if("line"==object1.type&&"circle"==object2.type){const point1=object1.point1,point2=object1.point2,midX=(point1.x+point2.x)/2,midY=(point1.y+point2.y)/2,lineWidth=object1.lineWidth;let radians=getAngle(midX,midY,point2.x,point2.y);const rect=getRectFromLine(point1,point2,midX,midY,lineWidth,radians),newPoint=getRotatedPos({x:midX,y:midY},{x:object2.x,y:object2.y},radians);let closestX,closestY;closestX=newPoint.x<rect.x?rect.x:newPoint.x>rect.x+rect.width?rect.x+rect.width:newPoint.x,closestY=newPoint.y<rect.y?rect.y:newPoint.y>rect.y+rect.height?rect.y+rect.height:newPoint.y;const distX=Math.abs(newPoint.x-closestX),distY=Math.abs(newPoint.y-closestY);return Math.sqrt(distX**2+distY**2)<object2.radius}if(("rect"==object1.type||"img"==object1.type)&&"line"==object2.type){const point1=object2.point1,point2=object2.point2,midX=(point1.x+point2.x)/2,midY=(point1.y+point2.y)/2,lineWidth=object2.lineWidth;let radians=getAngle(midX,midY,point2.x,point2.y);const rect=getRectFromLine(point1,point2,midX,midY,lineWidth,radians),points=[object1.hitbox.topLeft,object1.hitbox.topRight,object1.hitbox.bottomLeft,object1.hitbox.bottomRight],sides=[{point1:object1.hitbox.topLeft,point2:object1.hitbox.topRight},{point1:object1.hitbox.bottomLeft,point2:object1.hitbox.bottomRight},{point1:object1.hitbox.topLeft,point2:object1.hitbox.bottomLeft},{point1:object1.hitbox.topRight,point2:object1.hitbox.bottomRight}];for(let i=0;i<rect.points.length;i++){const points=rect.points,newPoint=getRotatedPos(origin,{x:points[i].x,y:points[i].y},radians),rectX=object1.x-object1.width/2,rectY=object1.y-object1.height/2;if(newPoint.x>rectX&&newPoint.x<rectX+object1.width&&newPoint.y>rectY&&newPoint.y<rectY+object1.height)return!0}radians=object1.rotation*Math.PI/180;for(let i=0;i<points.length;i++){const newPoint=getRotatedPos(origin,{x:points[i].x,y:points[i].y},radians);if(newPoint.x>rect.x&&newPoint.x<rect.x+rect.width&&newPoint.y>rect.y&&newPoint.y<rect.y+rect.height)return!0}for(let i=0;i<rect.sides.length;i++)for(let x=0;x<sides.length;x++)if(checkLines(rect.sides[i],sides[x]))return!0;return!1}if("line"==object1.type&&("rect"==object2.type||"img"==object2.type)){const point1=object1.point1,point2=object1.point2,midX=(point1.x+point2.x)/2,midY=(point1.y+point2.y)/2,lineWidth=object1.lineWidth;let radians=getAngle(midX,midY,point2.x,point2.y);const rect=getRectFromLine(point1,point2,midX,midY,lineWidth,radians),points=[object2.hitbox.topLeft,object2.hitbox.topRight,object2.hitbox.bottomLeft,object2.hitbox.bottomRight],sides=[{point1:object2.hitbox.topLeft,point2:object2.hitbox.topRight},{point1:object2.hitbox.bottomLeft,point2:object2.hitbox.bottomRight},{point1:object2.hitbox.topLeft,point2:object2.hitbox.bottomLeft},{point1:object2.hitbox.topRight,point2:object2.hitbox.bottomRight}];for(let i=0;i<rect.points.length;i++){const points=rect.points,newPoint=getRotatedPos(origin,{x:points[i].x,y:points[i].y},radians),rectX=object2.x-object2.width/2,rectY=object2.y-object2.height/2;if(newPoint.x>rectX&&newPoint.x<rectX+object2.width&&newPoint.y>rectY&&newPoint.y<rectY+object2.height)return!0}radians=object2.rotation*Math.PI/180;for(let i=0;i<points.length;i++){const newPoint=getRotatedPos(origin,{x:points[i].x,y:points[i].y},radians);if(newPoint.x>rect.x&&newPoint.x<rect.x+rect.width&&newPoint.y>rect.y&&newPoint.y<rect.y+rect.height)return!0}for(let i=0;i<rect.sides.length;i++)for(let x=0;x<sides.length;x++)if(checkLines(rect.sides[i],sides[x]))return!0;return!1}if("line"==object1.type&&"line"==object2.type){let point1=object1.point1,point2=object1.point2,midX=(point1.x+point2.x)/2,midY=(point1.y+point2.y)/2,lineWidth=object1.lineWidth;const origin1={x:midX,y:midY},radians1=getAngle(midX,midY,point2.x,point2.y),rect1=getRectFromLine(point1,point2,midX,midY,lineWidth,radians1);point1=object2.point1,point2=object2.point2,midX=(point1.x+point2.x)/2,midY=(point1.y+point2.y)/2,lineWidth=object2.lineWidth;const origin2={x:midX,y:midY},radians2=getAngle(midX,midY,point2.x,point2.y),rect2=getRectFromLine(point1,point2,midX,midY,lineWidth,radians2);for(let i=0;i<rect1.points.length;i++){const points=rect1.points,newPoint=getRotatedPos(origin2,{x:points[i].x,y:points[i].y},radians2);if(newPoint.x>rect2.x&&newPoint.x<rect2.x+rect2.width&&newPoint.y>rect2.y&&newPoint.y<rect2.y+rect2.height)return!0}for(let i=0;i<rect2.points.length;i++){const points=rect2.points,newPoint=getRotatedPos(origin1,{x:points[i].x,y:points[i].y},radians1);if(newPoint.x>rect1.x&&newPoint.x<rect1.x+rect1.width&&newPoint.y>rect1.y&&newPoint.y<rect1.y+rect1.height)return!0}for(let i=0;i<rect1.sides.length;i++)for(let x=0;x<rect2.sides.length;x++)if(checkLines(rect1.sides[i],rect2.sides[x]))return!0;return!1}if(!("rect"!=object1.type&&"img"!=object1.type||"rect"!=object2.type&&"img"!=object2.type)){const sides=[{point1:object1.hitbox.topLeft,point2:object1.hitbox.topRight},{point1:object1.hitbox.bottomLeft,point2:object1.hitbox.bottomRight},{point1:object1.hitbox.topLeft,point2:object1.hitbox.bottomLeft},{point1:object1.hitbox.topRight,point2:object1.hitbox.bottomRight}],sides0=[{point1:object2.hitbox.topLeft,point2:object2.hitbox.topRight},{point1:object2.hitbox.bottomLeft,point2:object2.hitbox.bottomRight},{point1:object2.hitbox.topLeft,point2:object2.hitbox.bottomLeft},{point1:object2.hitbox.topRight,point2:object2.hitbox.bottomRight}];let radians=object1.rotation*Math.PI/180,origin={x:object1.x,y:object1.y},points=[object2.hitbox.topLeft,object2.hitbox.topRight,object2.hitbox.bottomLeft,object2.hitbox.bottomRight];for(let i=0;i<points.length;i++){const newPoint=getRotatedPos(origin,{x:points[i].x,y:points[i].y},radians),rectX=object1.x-object1.width/2,rectY=object1.y-object1.height/2;if(newPoint.x>rectX&&newPoint.x<rectX+object1.width&&newPoint.y>rectY&&newPoint.y<rectY+object1.height)return!0}radians=object2.rotation*Math.PI/180,origin={x:object2.x,y:object2.y},points=[object1.hitbox.topLeft,object1.hitbox.topRight,object1.hitbox.bottomLeft,object1.hitbox.bottomRight];for(let i=0;i<points.length;i++){const newPoint=getRotatedPos(origin,{x:points[i].x,y:points[i].y},radians),rectX=object2.x-object2.width/2,rectY=object2.y-object2.height/2;if(newPoint.x>rectX&&newPoint.x<rectX+object2.width&&newPoint.y>rectY&&newPoint.y<rectY+object2.height)return!0}for(let i=0;i<sides.length;i++)for(let x=0;x<sides0.length;x++)if(checkLines(sides[i],sides0[x]))return!0;return!1}if("circle"==object1.type&&"circle"==object2.type){const distX=Math.abs(object1.x-object2.x),distY=Math.abs(object1.y-object2.y);return Math.sqrt(distX^2+distY^2)<object1.radius+object2.radius}if(("rect"==object1.type||"img"==object1.type)&&"circle"==object2.type){const radians=object1.rotation*Math.PI/180,rectX=object1.x-object1.width/2,rectY=object1.y-object1.height/2,newPoint=getRotatedPos({x:object1.x,y:object1.y},{x:object2.x,y:object2.y},radians);let closestX,closestY;closestX=newPoint.x<rectX?rectX:newPoint.x>rectX+object1.width?rectX+object1.width:newPoint.x,closestY=newPoint.y<rectY?rectY:newPoint.y>rectY+object1.height?rectY+object1.height:newPoint.y;const distX=Math.abs(newPoint.x-closestX),distY=Math.abs(newPoint.y-closestY);return Math.sqrt(distX**2+distY**2)<object2.radius}if("circle"==object1.type&&("rect"==object2.type||"img"==object2.type)){const radians=object2.rotation*Math.PI/180,rectX=object2.x-object2.width/2,rectY=object2.y-object2.height/2,newPoint=getRotatedPos({x:object2.x,y:object2.y},{x:object1.x,y:object1.y},radians);let closestX,closestY;closestX=newPoint.x<rectX?rectX:newPoint.x>rectX+object2.width?rectX+object2.width:newPoint.x,closestY=newPoint.y<rectY?rectY:newPoint.y>rectY+object2.height?rectY+object2.height:newPoint.y;const distX=Math.abs(newPoint.x-closestX),distY=Math.abs(newPoint.y-closestY);return Math.sqrt(distX**2+distY**2)<object1.radius}if("polygon"==object1.type&&"circle"==object2.type){const points=[],sides=[],radians=object1.rotation*Math.PI/180,origin={x:object1.x,y:object1.y};for(let i=0;i<object1.points.length;i++){const newPoint=getRotatedPos(origin,object1.points[i],-radians);points.push(newPoint)}for(let i=0;i<object1.sides.length;i++){const newPoint1=getRotatedPos(origin,object1.sides[i].point1,-radians),newPoint2=getRotatedPos(origin,object1.sides[i].point2,-radians);sides.push({point1:newPoint1,point2:newPoint2})}for(let i=0;i<sides.length;i++)if(checkLineCircle(sides[i].point1,sides[i].point2,object2))return!0;return!!checkPolygonPoint(points,object2)}if("circle"==object1.type&&"polygon"==object2.type){const points=[],sides=[],radians=object2.rotation*Math.PI/180,origin={x:object2.x,y:object2.y};for(let i=0;i<object2.points.length;i++){const newPoint=getRotatedPos(origin,object2.points[i],-radians);points.push(newPoint)}for(let i=0;i<object2.sides.length;i++){const newPoint1=getRotatedPos(origin,object2.sides[i].point1,-radians),newPoint2=getRotatedPos(origin,object2.sides[i].point2,-radians);sides.push({point1:newPoint1,point2:newPoint2})}for(let i=0;i<sides.length;i++)if(checkLineCircle(sides[i].point1,sides[i].point2,object1))return!0;return!!checkPolygonPoint(points,object1)}if("polygon"==object1.type&&"polygon"==object2.type){const points1=[],points2=[],sides1=[],sides2=[];let radians=object1.rotation*Math.PI/180,origin={x:object1.x,y:object1.y};for(let i=0;i<object1.points.length;i++){const newPoint=getRotatedPos(origin,object1.points[i],-radians);points1.push(newPoint)}for(let i=0;i<object1.sides.length;i++){const newPoint1=getRotatedPos(origin,object1.sides[i].point1,-radians),newPoint2=getRotatedPos(origin,object1.sides[i].point2,-radians);sides1.push({point1:newPoint1,point2:newPoint2})}radians=object2.rotation*Math.PI/180,origin={x:object2.x,y:object2.y};for(let i=0;i<object2.points.length;i++){const newPoint=getRotatedPos(origin,object2.points[i],-radians);points2.push(newPoint)}for(let i=0;i<object2.sides.length;i++){const newPoint1=getRotatedPos(origin,object2.sides[i].point1,-radians),newPoint2=getRotatedPos(origin,object2.sides[i].point2,-radians);sides2.push({point1:newPoint1,point2:newPoint2})}for(let i=0;i<points1.length;i++)if(checkPolygonPoint(points2,points1[i]))return!0;for(let i=0;i<points2.length;i++)if(checkPolygonPoint(points1,points2[i]))return!0;for(let i=0;i<sides1.length;i++)for(let j=0;j<sides2.length;j++)if(checkLines(sides1[i],sides2[j]))return!0;return!1}if(("rect"==object1.type||"img"==object1.type)&&"polygon"==object2.type){const sides1=[{point1:object1.hitbox.topLeft,point2:object1.hitbox.topRight},{point1:object1.hitbox.bottomLeft,point2:object1.hitbox.bottomRight},{point1:object1.hitbox.topLeft,point2:object1.hitbox.bottomLeft},{point1:object1.hitbox.topRight,point2:object1.hitbox.bottomRight}],sides2=[],points1=[object1.hitbox.topLeft,object1.hitbox.topRight,object1.hitbox.bottomLeft,object1.hitbox.bottomRight],points2=[];let radians=object2.rotation*Math.PI/180,origin={x:object2.x,y:object2.y};for(let i=0;i<object2.sides.length;i++){const newPoint1=getRotatedPos(origin,object2.sides[i].point1,-radians),newPoint2=getRotatedPos(origin,object2.sides[i].point2,-radians);sides2.push({point1:newPoint1,point2:newPoint2})}for(let i=0;i<sides1.length;i++)for(let j=0;j<sides2.length;j++)if(checkLines(sides1[i],sides2[j]))return!0;for(let i=0;i<object2.points.length;i++){const point=getRotatedPos(origin,object2.points[i],-radians);points2.push(point)}for(let i=0;i<points1.length;i++)if(checkPolygonPoint(points2,points1[i]))return!0;const rectX=object1.x-object1.width/2,rectY=object1.y-object1.height/2;radians=object1.rotation*Math.PI/180,origin={x:object1.x,y:object1.y};for(let i=0;i<points2.length;i++){const newPoint=getRotatedPos(origin,points2[i],radians);if(newPoint.x>rectX&&newPoint.x<rectX+object1.width&&newPoint.y>rectY&&newPoint.y<rectY+object1.height)return!0}return!1}if("polygon"==object1.type&&("rect"==object2.type||"img"==object2.type)){const sides1=[{point1:object2.hitbox.topLeft,point2:object2.hitbox.topRight},{point1:object2.hitbox.bottomLeft,point2:object2.hitbox.bottomRight},{point1:object2.hitbox.topLeft,point2:object2.hitbox.bottomLeft},{point1:object2.hitbox.topRight,point2:object2.hitbox.bottomRight}],sides2=[],points1=[object2.hitbox.topLeft,object2.hitbox.topRight,object2.hitbox.bottomLeft,object2.hitbox.bottomRight],points2=[];let radians=object1.rotation*Math.PI/180,origin={x:object1.x,y:object1.y};for(let i=0;i<object1.sides.length;i++){const newPoint1=getRotatedPos(origin,object1.sides[i].point1,-radians),newPoint2=getRotatedPos(origin,object1.sides[i].point2,-radians);sides2.push({point1:newPoint1,point2:newPoint2})}for(let i=0;i<sides1.length;i++)for(let j=0;j<sides2.length;j++)if(checkLines(sides1[i],sides2[j]))return!0;for(let i=0;i<object1.points.length;i++){const point=getRotatedPos(origin,object1.points[i],-radians);points2.push(point)}for(let i=0;i<points1.length;i++)if(checkPolygonPoint(points2,points1[i]))return!0;const rectX=object2.x-object2.width/2,rectY=object2.y-object2.height/2;radians=object2.rotation*Math.PI/180,origin={x:object2.x,y:object2.y};for(let i=0;i<points2.length;i++){const newPoint=getRotatedPos(origin,points2[i],radians);if(newPoint.x>rectX&&newPoint.x<rectX+object2.width&&newPoint.y>rectY&&newPoint.y<rectY+object2.height)return!0}return!1}if("polygon"==object1.type&&"line"==object2.type){const point1=object2.point1,point2=object2.point2,midX=(point1.x+point2.x)/2,midY=(point1.y+point2.y)/2,lineWidth=object2.lineWidth,radians1=getAngle(midX,midY,point2.x,point2.y),rect=getRectFromLine(point1,point2,midX,midY,lineWidth,radians1),points1=[],points2=rect.points,sides1=[],sides2=rect.sides,radians2=object1.rotation*Math.PI/180,origin={x:object1.x,y:object1.y};for(let i=0;i<object1.points.length;i++){const newPoint=getRotatedPos(origin,object1.points[i],-radians2);points1.push(newPoint)}for(let i=0;i<object1.sides.length;i++){const newPoint1=getRotatedPos(origin,object1.sides[i].point1,-radians2),newPoint2=getRotatedPos(origin,object1.sides[i].point2,-radians2);sides1.push({point1:newPoint1,point2:newPoint2})}for(let i=0;i<points1.length;i++){const newPoint=getRotatedPos({x:midX,y:midY},points1[i],radians1);if(newPoint.x>rect.x&&newPoint.x<rect.x+rect.width&&newPoint.y>rect.y&&newPoint.y<rect.y+rect.height)return!0}for(let i=0;i<points2.length;i++)if(checkPolygonPoint(points1,points2[i]))return!0;for(let i=0;i<sides1.length;i++)for(let j=0;j<sides2.length;j++)if(checkLines(sides1[i],sides2[j]))return!0;return!1}if("line"==object1.type&&"polygon"==object2.type){const point1=object1.point1,point2=object1.point2,midX=(point1.x+point2.x)/2,midY=(point1.y+point2.y)/2,lineWidth=object1.lineWidth,radians1=getAngle(midX,midY,point2.x,point2.y),rect=getRectFromLine(point1,point2,midX,midY,lineWidth,radians1),points1=[],points2=rect.points,sides1=[],sides2=rect.sides,radians2=object2.rotation*Math.PI/180,origin={x:object2.x,y:object2.y};for(let i=0;i<object2.points.length;i++){const newPoint=getRotatedPos(origin,object2.points[i],-radians2);points1.push(newPoint)}for(let i=0;i<object2.sides.length;i++){const newPoint1=getRotatedPos(origin,object2.sides[i].point1,-radians2),newPoint2=getRotatedPos(origin,object2.sides[i].point2,-radians2);sides1.push({point1:newPoint1,point2:newPoint2})}for(let i=0;i<points1.length;i++){const newPoint=getRotatedPos({x:midX,y:midY},points1[i],radians1);if(newPoint.x>rect.x&&newPoint.x<rect.x+rect.width&&newPoint.y>rect.y&&newPoint.y<rect.y+rect.height)return!0}for(let i=0;i<points2.length;i++)if(checkPolygonPoint(points1,points2[i]))return!0;for(let i=0;i<sides1.length;i++)for(let j=0;j<sides2.length;j++)if(checkLines(sides1[i],sides2[j]))return!0;return!1}},Loop=function(func,timeInMs){if(null==timeInMs){function loop(){"function"==typeof func&&func(),"function"==typeof loop&&requestAnimationFrame(loop)}return loop(),{ClearLoop:function(){loop=void 0}}}{"function"==typeof func&&func();const loop=setInterval((function(){"function"==typeof func&&func()}),timeInMs);return{ClearLoop:function(){clearInterval(loop)}}}},Repeat=function(func,num){let i;for(num=Math.round(num),i=0;i<num;i++)"function"==typeof func&&func();return{Stop:function(){i=num}}},After=function(timeInMs,func){return"function"==typeof func&&setTimeout(func,timeInMs),timeInMs},RandomNum=function(minimum,maximum){return Math.random()*(maximum-minimum+1)+minimum},RandomInt=function(minimum,maximum){return Math.floor(Math.random()*(maximum-minimum+1)+minimum)},GetDistance=function(point1,point2){const x1=point1[0],y1=point1[1],x2=point2[0],y2=point2[1],distX=Math.abs(x2-x1),distY=Math.abs(y2-y1);return Math.sqrt(distX**2+distY**2)},GetMidPoint=function(point1,point2){const x1=point1[0],y1=point1[1];return{x:(x1+point2[0])/2,y:(y1+point2[1])/2}},GetAngle=function(midPoint,point){const x1=midPoint[0],y1=midPoint[1],distX=point[0]-x1,distY=point[1]-y1;return 180*Math.atan2(distY,distX)/Math.PI},DegreesToRadians=function(degrees){return degrees*Math.PI/180},RadiansToDegrees=function(radians){return radians/180*Math.PI},GetRotatedPosition=function(origin,point,degrees){const originX=origin[0],originY=origin[1],pointX=point[0],pointY=point[1],radians=degrees*Math.PI/180;return{x:Math.cos(-radians)*(pointX-originX)+Math.sin(-radians)*(pointY-originY)+originX,y:Math.cos(-radians)*(pointY-originY)-Math.sin(-radians)*(pointX-originX)+originY}};document.addEventListener("keydown",(function(event){KeysPressed[event.code]=!0}),!1),document.addEventListener("keyup",(function(event){KeysPressed[event.code]=!1}),!1),document.addEventListener("mousedown",(function(){IsMouseDown=!0}),!1),document.addEventListener("mouseup",(function(){IsMouseUp=!1}),!1);
